--------------------------------------------------------------------------------------------
说明

    运营的时候，由于某些原因，需要进行合服。合服时，把两组服务器的数据库合并到一个
新库中。在同一组服务器中，角色名是唯一的，但两组服务器之间有可能重名，这样合服就会
遇到问题。为了处理这个问题，引入合服组的概念。

    合服组：合服组内的所有服务器的角色名字在分配时就保证是唯一的。只有一个合服组内
的服务器可以合并，合服组之间的服务器不能合并。每个合服组配置一个唯一名服务器。组内
名字的唯一性由唯一名服务器保证。

    唯一名服务器除了管理角色名字，还管理了名字，公会名字，等所有可自定义的名字。
在合服时，除了名字，还需要确保所有程序分配的ID都是唯一的。这也由唯一名服务里管理。

--------------------------------------------------------------------------------------------
安装和使用
	请阅读 install.txt

--------------------------------------------------------------------------------------------
名字唯一分配实现

一、名字分配接口 

    see Mkdb.util.UniqName
    包装了惟一名服务器协议，和事务统一起来，便于使用。

    /**
     * 名字分配。
     * 向惟一名服务器发送名字分配请求，并返回结果。
     * 
     * 如果分配成功，会记录日志，在事务成功时，自动发送确认请求(Confirm)。
     * 如果事务失败，自动发送释放请求(Release)。 
     *
     * @param group 名字所在分组（即名字空间）。如："role"(角色名)，"family"(名)，"faction"(公会名)
     * @param name  名字。
     * @return true 分配成功；false 分配失败；
     */
    public static boolean allocate(String group, String name)

    /**
     * 释放名字。
     * 
     * [注意] 这个方法会忽略所有的错误。
     * 
     * @param group
     * @param name
     */
    public static void release(String group, String name) {

    /**
     * 名字是否存在。
     * @return
     *       RPC_OK               name exist
     *       RPC_NOT_EXISTS       name not exist
     *       RPC_EXCEPTION        UniqName server exception
     *       RPC_GROUP_NOT_EXISTS group not exist
     */
    public static boolean exist(String group, String name)

二、名字分配协议

    Allocate(group, name) 分配名字。
    Confirm(group, name)  确认名字。
    Release(group, name)  释放名字。
    Exist(group, name)    名字是否存在。

三、唯一ID本地分配方案

    唯一名服务器并不直接参与ID分配。
    开新服时，给新服务器分配一个合服组内唯一的服务号(localId)。服务号可用范围是0~4095。
    服务器根据localId分配合服组内唯一的ID。

    ID长度：64位。保证有足够的ID空间。
    ID编码：本地服务器分配的ID + localId。0~11: localId；12~62: 自增长ID；63: 保留；
    分配规则：每次把种子ID递增4096。参考，Mkdb.util.AuthKeys。
 
    注意：
    服务号(localId)在一个合服组内必须唯一。用过的ID不能再次使用。
    也就是说一个合服组最多只能开4096组服务器。
    按每周消耗两个服务号，够用 47 年(4096/52/2=47)。基本够用了。
    localId分配完以后解决方案已经考虑到了：
    因为ID长度很长，所以合服的时候，很多空间还未使用，所以只要在合服时记住所有的autokey。
    以后是可以把未分配完的autokey拿出来重复使用的。这个等localId用完了再说。

--------------------------------------------------------------------------------------------
唯一ID分配实现

一、ID分配接口

    /**
     * 分配ID。服务器会在允许的范围内，尽量按顺序分配ID。
     *
     * 向惟一名服务器发送ID分配请求，并返回结果。
     * 
     * 如果分配成功，会记录日志，如果以后事务失败了，自动发送释放请求(ReleaseId)。
     *
     * @param group    名字所在分组（即名字空间）。如："roleid"(角色名)，"familyid"(名)，"factionid"(公会名)
     * @param exceptId 期望的ID。如果可用，则返回这个ID。
     * @return         分配成功返回的ID；null表示分配失败，失败时，内部会记录详细日志；
     */
    public static Long allocateId(String group, long exceptId)

    /**
     * 释放ID。可以再次被分配。
     * 
     * [注意] 忽略所有错误。
     */
    public static void releaseId(String group)

二、ID分配协议

    AllocateId  分配ID请求
    ReleaseId   释放ID请求

--------------------------------------------------------------------------------------------
唯一名服务器综合应用

方案一
    UniqName.allocate(名字分配) + localId(本地ID分配)

    这是一开始设计的方案，目标是最小化唯一名服务器的责任。因为唯一名服务器和逻辑服务器在两个程序中，
数据完整性是没法保证的。如果唯一名服务器发生了回档或者数据丢失，就会出现重复的名字或ID。这样，
在合服时需要做很多处理。
    这个方案只管理名字，如果出现问题，只有重复的名字需要处理。由于名字只保存在很少的表中，处理起来相对容易。
而如果ID出现重复，它可能出现在很多表中，处理会比较麻烦。
    推荐使用这个方案。

方案二
    UniqName.allocate(名字分配) + UniqName.allocateId(ID分配)

    名字和ID都让唯一名服务器管理。请参考方案一。

--------------------------------------------------------------------------------------------
唯一不唯一的问题：

	如果唯一名服务器发生了数据丢失或者回档。那么唯一性就会出问题。
	考虑中解决方法：
	gsd访问ns时本地记录一个accessTime；ns被访问时也记录accessTime。
	当gsd连接到ns时，发送自己的accessTime。Uniqname 比较两个accessTime，
	如果received.accessTime > local.accessTime就拒绝服务。必须手动解决了问题才提供服务。
	这个方法存在两个问题：
	1.	两个服务器的时间必须同步；怎么保证，或者采用其他东西代替时间戳。
	2.	手动解决的工具怎么定义？如：把当前已分配的所有名字或者id都搜索一遍，
	把数据恢复到正常状态，修改accessTime，重新启动。
