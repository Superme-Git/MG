// pfspatcher.cpp 
//
// pfspatcher - a commandline tool used to patch a file to the data.pfs generated by PackZip.exe.  
//				See usage section for detailed info.
//
// 2010-11-11 V0.8.0 - supports to only patch one file each time.
// 
// yanghaibo
//
#include "stdafx.h"
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <string.h>

// pfs header
#include "../../pfs2.h"
#include "../../src/utility/md5hash.h"
#include "../../stringhelper.h"
#include "../../filesmetafile.h"
#include "../../setupmetafile.h"
#include "../../src/zip/ziphelper.h"
#include "../../src/native/rawfileio.h"
#include "../../src/native/tempfile.h"

namespace std
{
#if defined _UNICODE || defined UNICODE
	typedef wstring tstring;
#else
	typedef string tstring;
#endif
}

#define WIDEN2(x) L ## x
#define WIDEN(x) WIDEN2(x)
#define __TIMESTAMPW__ WIDEN(__DATE__) L" " WIDEN(__TIME__)
#define VERSION_STRING L"Version 0.8.0 - Compiled at " __TIMESTAMPW__


#define OPT_TARGET_FILE _T("--target-file:")
#define OPT_SOURCE_FILE _T("--source-file:")

void usage( _TCHAR* arg0 )
{
	_tprintf(_T("Usage: %s <pfspackagefile> ") OPT_TARGET_FILE _T("<targetfilepath> ") OPT_SOURCE_FILE _T("<sourcefilepath>\n"), arg0);
	_putts(  _T("  Options:"));
	_putts(  _T("   <pfspackagefile> : usually data.pfs."));
	_putts(  _T("   <targetfilepath> : file to be replaced within <pfspackagefile>, like /wtf/servers.xml."));
	_putts(  _T("   <sourcefilepath> : file to replace, like wtf/servers.xml."));
	_putts( VERSION_STRING );
	_exit( -1 );
}

void check_args(std::tstring packagefile,
	std::tstring targetfile,
	std::tstring sourcefile)
{
	int ret = 0;
	if( !packagefile.empty() )
	{
		if( PFS::CFile::IsFileExisting( packagefile ) )
		{
			_tprintf(_T("packagefile : %s\n"), packagefile.c_str() );
		}
		else
		{
			_tprintf(_T("packagefile : %s - not exists.\n"), packagefile.c_str() );	
			ret |= 1;
		}
	}
	else
	{
		_putts(  _T("Missing packagefile argument."));
		ret |= 1;
	}

	if( !targetfile.empty() )
	{
		_tprintf(_T("targetfile  : %s\n"), targetfile.c_str() );
	}
	else
	{
		_putts(  _T("Missing targetfile argument."));
		ret |= 2;
	}

	if( !sourcefile.empty() )
	{
		if( PFS::CFile::IsFileExisting( sourcefile ) )
		{
			_tprintf(_T("sourcefile  : %s\n"), sourcefile.c_str() );
		}
		else
		{
			_tprintf(_T("sourcefile  : %s - not exists.\n"), sourcefile.c_str() );
		}
	}
	else
	{
		_putts(  _T("Missing sourcefile argument."));
		ret |= 4;
	}

	if( ret != 0 )
	{
		exit( ret );
	}
}

void parse_opts(int argc, _TCHAR* argv[],
				std::tstring& packagefile,
				std::tstring& targetfile,
				std::tstring& sourcefile)
{
	// parse arguments.
	for( int i = 1; i < argc; i ++ )
	{
		if ( argv[i][0] != _T('-') )
		{
			packagefile = argv[i];
		}
		else
		{
			const size_t prefix1_len = _tcslen(OPT_TARGET_FILE);
			const size_t prefix2_len = _tcslen(OPT_SOURCE_FILE); 
			// Acturally they are of same length.
			if ( 0 == _tcsncmp( argv[i], OPT_TARGET_FILE, prefix1_len ) )
			{
				targetfile = &argv[i][prefix1_len];
			}
			else if(  0 == _tcsncmp( argv[i], OPT_SOURCE_FILE, prefix2_len ) )
			{
				sourcefile = &argv[i][prefix2_len];
			}
		}
	}
}

const int X2OID = PFSX::MakeTypeIDByName( 'X', '2', 'O');

// bool MakeBaseFileCRC32( CBaseFile& file, unsigned int& crc32 );
const int BUFFERSIZE = 65535;

unsigned int MakeFileCRC32( PFS::CBaseFile& file)
{
	ZIPFILE::helper::CCRC32 crc32;
	file.Seek( 0, PFS::FSM_SET);
	static char buffer[BUFFERSIZE] = {0};
	while( size_t s = file.Read( buffer, BUFFERSIZE))
	{
		if( PFS::FILE_SIZE_ERROR == s)
		{
			break;
		}
		crc32.Update( buffer, s);
	}
	return crc32.GetValue();
}


static bool _CopyBaseFile( PFS::CBaseFile& source, PFS::CBaseFile& dest )
{
	PFS::CBaseFile*	fsrc = &source;
	PFS::CBaseFile*	fdst = &dest;
	const int	nBufferSize = 4096;
	unsigned char byteBuffer[nBufferSize];
	bool		bResult = true;
	size_t		s = 0;
	while( s = fsrc->Read( byteBuffer, nBufferSize ) )
	{
		if( PFS::FILE_SIZE_ERROR == s )
			return false;
		s = fdst->Write( byteBuffer, s);
		if( PFS::FILE_SIZE_ERROR == s )
			return false;
	}

	return true;
}

void update_metainfo( PFS::CBaseFile& sourceFile, PFS::CBaseFile& tempFile, PFS::CMetaInfo& rMetaInfo )
{
	// 更新crc
	unsigned int crc = MakeFileCRC32( sourceFile );
	rMetaInfo.SetCRC32( crc );
	PFS::TSID encoder = rMetaInfo.GetTSID();
	if( encoder == 0 || encoder == X2OID )
	{
		// 对于不转换以及X2O格式的文件，使用原始文件生成HASH值，SIZE值和HASH2值，SIZE2值。
		tempFile.Seek( 0, PFS::FSM_SET);
		PFS::CFileMetaInfo::MakeFileMetaInfoBoth( tempFile, rMetaInfo );
	}
	else
	{
		// 对于其它格式的文件，使用原始文件生成原始HASH值，SIZE值；
		// 使用转换后的文件生成HASH2值，SIZE2值。

		// 计算原始文件的HASH值。
		sourceFile.Seek( 0, PFS::FSM_SET);
		PFS::CFileMetaInfo::MakeFileMetaInfo( sourceFile, rMetaInfo );

		// 计算转换后文件的HASH值。
		tempFile.Seek( 0, PFS::FSM_SET);
		PFS::CFileMetaInfo::MakeFileMetaInfo2( tempFile, rMetaInfo );
	}
}

inline std::wstring TSID2String(PFS::TSID tsid)
{
	std::wstring str(4,0);
	str[0] = tsid&0xFF;
	str[1] = (tsid>>8)&0xFF;
	str[2] = (tsid>>16)&0xFF;
	str[3] = (tsid>>24)&0xFF;
	return str;
}

bool do_patch(std::wstring root,
			  std::tstring& targetfile,
			  std::tstring& sourcefile)
{
	PFS::CMetaInfo metainfo;
	PFS::CMetaInfoMap metainfomap2;
	if( !PFS::CEnv::GetFileMetaInfo( root + targetfile, metainfo ) )
	{
		wprintf( _T("No metainfo for file %s.\n"), targetfile.c_str() );
		return false;
	}
	
	PFS::CFile targetFile;
	if( !targetFile.Open(root + targetfile, PFS::FM_EXCL, PFS::FA_RDWR ) )
	{
		wprintf( _T("Open %s failed(%d).\n"),
			targetfile.c_str(), PFS::CEnv::GetLastError() );
		return false;
	}

	PFS::CFile sourceFile;
	if( !sourceFile.Open(sourcefile, PFS::FM_EXCL, PFS::FA_RDONLY ) )
	{
		wprintf( _T("Open %s failed(%d).\n"), 
			sourcefile.c_str(), PFS::CEnv::GetLastError() );
		return false;
	}
	
	PFSX::SetupMetaVector setupMetas;
	if( !PFSX::CSetupMetaFile::DoRead( root + PFSX::SETUP_META_NAME, setupMetas) )
	{
		wprintf( _T("CSetupMetaFile::DoRead(%s) failed(%d).\n"), 
			(root + PFSX::SETUP_META_NAME).c_str(),
			PFS::CEnv::GetLastError() );
		return false;
	}

	wprintf( _T("setup.meta loaded.\n") );

	// targetfile 不一定在散目录中，有可能在子包中，
	// 此时，需要更新子包的.files2.meta，而不是根目录的.files2.meta.
	// 确定.files2.meta在哪里，需要根据.setup.meta确定。

	std::wstring subpackage; // 确定子包名。为空表示不在任何子包中。
	PFSX::SetupMetaVector::iterator itr = setupMetas.begin();
	for(; itr != setupMetas.end(); ++ itr )
	{
		if( 0 == (*itr).GetName().compare(0,-1,targetfile,0,(*itr).GetName().size() ) )
		{
			subpackage = (*itr).GetName();
			
			wprintf( _T("subpackage is %s\n."), subpackage.c_str() );
			break;
		}
	}

	std::wstring meta2filepath = root + subpackage + PFSX::FILES2_META_NAME;	
	if( !PFSX::ReadMetaInfoFile( meta2filepath, metainfomap2 ) )
	{
		wprintf( _T("ReadMetaInfoFile(%s) failed(%d).\n"), 
			meta2filepath.c_str(),
			PFS::CEnv::GetLastError() );
		return false;
	}

	wprintf( _T("%s - loaded.\n"), meta2filepath.c_str() );

	PFS::TSID encoder = metainfo.GetTSID();

	wprintf( _T("Encoder %d(%s).\n"), encoder, TSID2String(encoder).c_str() );

	PFS::CTempFile tempFile;
	tempFile.Open();

	if( !PFSX::EncodeFile( &sourceFile, &tempFile, encoder ) )
	{
		wprintf( _T("Encode File %s -> %s failed(%d).\n"), 
			sourcefile.c_str(), targetfile.c_str(), 
			PFS::CEnv::GetLastError() );
		return false;
	}

	wprintf( _T("%s was translated to temp file: %s.\n"),
		sourcefile.c_str(), tempFile.GetFileName().c_str() );

	// 计算新文件的metainfo
	PFS::CMetaInfo metainfo_new(metainfo);
	update_metainfo( sourceFile, tempFile, metainfo_new );
	if( !PFS::CEnv::SetFileMetaInfo( root + targetfile, metainfo_new ) )
	{
		wprintf( _T("SetFileMetaInfo File %s failed(%d).\n"), 
			targetfile.c_str(), 
			PFS::CEnv::GetLastError() );

		return false;
	}

	wprintf( _T("metainfo of %s was generated and saved to pfs env.\n"), targetfile.c_str() );
	metainfomap2[ targetfile ] = metainfo_new;

	tempFile.Seek( 0, PFS::FSM_SET );
	if( !_CopyBaseFile( tempFile, targetFile ) )
	{
		wprintf( _T("Save temp file to target %s failed(%d).\n"), targetfile.c_str(), PFS::CEnv::GetLastError() );
		return false;
	}

	wprintf( _T("Data of %s was saved to pfs.\n"), targetfile.c_str() );
	
	// 更新.files2.meta
	PFS::CFile theFile; // 这里要重用theFile对象，所以没有直接使用PFSX::WriteMetaInfoFile()函数。
	if( theFile.Open( meta2filepath, PFS::FM_CREAT|PFS::FM_TRUNC, PFS::FA_RDWR) )
	{
		if( !PFS::CMetaFileWrite::DoWriteByVersion( theFile, metainfomap2, 0x0101 ))
		{
			wprintf( _T("PFS::CMetaFileWrite::DoWriteByVersion(%s) failed(%d).\n"), 
				meta2filepath.c_str(),
				PFS::CEnv::GetLastError() );
			return false;
		}
		else
		{
			wprintf( _T("%s was saved to pfs.\n"), meta2filepath.c_str() );
		}
	}
	else
	{
		wprintf( _T("Open %s failed(%d).\n"), 
			meta2filepath.c_str(),
			PFS::CEnv::GetLastError() );
		return false;
	}

	// 如果子包中的.files2.meta更新了，还需要更新.setup.meta。根中的meta2暂时无需更新.setup.meta。
	if( !subpackage.empty() )
	{
		{
			PFS::FILE_DATA_HASH datahash2 = 0;
			PFS::helper::CMD5FileHashMethod md5hash;
			theFile.Seek(0, PFS::FSM_SET);
			md5hash.MakeFileHash(theFile, datahash2);
			(*itr).SetHash2(datahash2);

			wprintf( _T("Hash2 of %s generated and saved to setup.meta - %s.\n"),
				meta2filepath.c_str(),
				PFSX::CStringHelper::Hash2String(datahash2).c_str() );
		}

		{
			PFS::CTempFile tf; tf.Open();			
			if( ! PFS::CMetaFileWrite::DoWrite( tf, metainfomap2 ) )
			{
				wprintf( _T("PFS::CMetaFileWrite::DoWrite(%s) failed(%d).\n"), 
					tf.GetFileName().c_str(),
					PFS::CEnv::GetLastError() );
				return false;
			}

			PFS::helper::CMD5FileHashMethod md5hash;
			PFS::FILE_DATA_HASH datahash = 0;
			tf.Seek(0, PFS::FSM_SET);
			md5hash.MakeFileHash(tf, datahash);
			(*itr).SetHash(datahash);
			wprintf( _T("Hash of %s generated and saved to setup.meta - %s.\n"), meta2filepath.c_str(),
				PFSX::CStringHelper::Hash2String(datahash).c_str() );
		}

		if( !PFSX::CSetupMetaFile::DoWrite( root + PFSX::SETUP_META_NAME, setupMetas) )
		{
			wprintf( _T("CSetupMetaFile::DoWrite(%s) failed(%d).\n"), 
				(root + PFSX::SETUP_META_NAME).c_str(),
				PFS::CEnv::GetLastError() );
			return false;
		}
		else
		{
			wprintf( _T("%s was saved.\n"), PFSX::SETUP_META_NAME.c_str() );
		}
	}

	// TODO: 处理.version.meta需要更新的问题。
	// TODO: 考虑更新MD5文件

	return true;
}

int _tmain(int argc, _TCHAR* argv[])
{
	setlocale( LC_CTYPE, ".936" );
	setlocale( LC_CTYPE, ".936" );
	if( argc != 4 )
	{
		usage(argv[0]);
	}

	std::tstring packagefile;
	std::tstring targetfile;
	std::tstring sourcefile;

	parse_opts( argc, argv, packagefile, targetfile, sourcefile );
	
	check_args( packagefile, targetfile, sourcefile );

	std::wstring root(L"/run");

	if( !PFS::CEnv::Mount( root, packagefile, PFS::FST_ZIP, PFS::MT_WRITABLE ) )
	{
		wprintf( _T("Mount package %s failed(%d).\n"), packagefile.c_str(), PFS::CEnv::GetLastError() );
		return -1;
	}

	bool bNeedCommit = do_patch( root, targetfile, sourcefile);

	bool bDone = PFS::CEnv::Unmount( root, bNeedCommit );

	if( bDone )
	{
		_putts( _T("DONE!") );
	}
	else
	{
		_putts( _T("FAILED!") );
	}

	return bDone ? 0 : -1;
}

