// gxwencodertest.cpp : 定义控制台应用程序的入口点。
//

#include "windows.h"
#include <iostream>
#include <tchar.h>
#include <io.h>
#include "../gxwencoder2/gxwencoder.h"

CGxWEncoder g_gxwencoder;

void PrintUsage( const char* szName)
{
	printf( "usage: %s xml [-m D|F] [-o outdir] [-l inlfile outdir] [-i gxwindow.h] [-acpp \"#include \\\"example1.h\\\";#include <example2.h>\"] [-autoptr] [-f] [-p] [-t textformat.xml] [-namespace NS1.NS2.NS3] [-res textResXMLFile] [-g Option] [-c timefile]\n", szName);
	printf( "\t[m] make directory[D] or file[F]\n");
	printf( "\t[o] out put path\n");
	printf( "\t[l] inl file out put path\n");
	printf( "\t[i] gxwindow header file\n");
	printf( "\t[acpp] append include files in cpp\n");
	printf( "\t[autoptr] create pointer class\n");
	printf( "\t[f] using the xml filename as the prefix of out output files\n");
	printf( "\t[p] load picture with pak mod\n");
	printf( "\t[t] using text format xml\n");
	printf( "\t[namespace] set namespaces\n");
	printf( "\t[res] using text res file\n");
	printf( "\t[g] set generate mode, 3 options:\n");
	printf( "\t    code  - generate full code for UI, default option\n");
	printf( "\t    frame - generate frame code and use GXWADDIN::CGuiGenerator to setup the components\n");
	printf( "\t    both  - generated by 2 modes, switch by macros [GXWE_GENERATEMODE_FRAME]\n");
	printf( "\t[c] set timefiles' path to check the xml filetime\n");
}

int OutPutFile()
{
	std::string xmlfile = g_gxwencoder.GetXmlFileName();
	DWORD dwAttr = GetFileAttributes( xmlfile.c_str());
	if( -1 == dwAttr)
	{
		printf( "input file not existing!\n");
		return -2;
	}
	if( FILE_ATTRIBUTE_DIRECTORY == ( dwAttr & FILE_ATTRIBUTE_DIRECTORY))
	{
		printf( "input not a file!\n");
		return -3;
	}

	int rs = g_gxwencoder.Encode();
	return rs;
}

int OutPutOnePath( const std::string& szSrc, const std::string& szName)
{
	std::string strSrcFile = szSrc;
	strSrcFile += "\\";
	strSrcFile += szName;
	g_gxwencoder.SetXmlFileName( strSrcFile);

	printf( "encode %s ....\n", strSrcFile.c_str());
	return g_gxwencoder.Encode();
}

int OutPutPath( const std::string& szSrc)
{
	DWORD dwAttr = GetFileAttributes( szSrc.c_str());
	if( -1 == dwAttr)
	{
		printf( "input directory not existing!\n");
		return -2;
	}
	if( FILE_ATTRIBUTE_DIRECTORY != ( dwAttr & FILE_ATTRIBUTE_DIRECTORY))
	{
		printf( "input not a file!\n");
		return -3;
	}

	WIN32_FIND_DATA		wfd;

	std::string	strFindFilter = szSrc;
	strFindFilter += "\\*.xml";
	HANDLE hFind = FindFirstFile( strFindFilter.c_str(), &wfd);
	if( INVALID_HANDLE_VALUE == hFind)
	{
		printf( "not xml file found!\n");
		return 0;
	}
	OutPutOnePath( szSrc, wfd.cFileName);

	while( FindNextFile( hFind, &wfd))
	{
		OutPutOnePath( szSrc, wfd.cFileName);
	}
	FindClose( hFind);
	return 0;
}

// 返回true表示时间戳文件比xml文件新, 不需要重新生成代码了
bool CheckXmlFileTime( const std::string& xmlfile, const std::string& timefilesPath)
{
	static const std::string tmposfix = ".tm";

	char currentPath[MAX_PATH];
	GetCurrentDirectory( MAX_PATH, currentPath);

	bool result = false;
	size_t pos = xmlfile.find_last_of( "\\/");
	std::string filename = timefilesPath;
	filename += "\\";
	filename += xmlfile.substr( pos + 1);
	filename += tmposfix;
	if ( pos != std::string::npos)
	{
		WIN32_FIND_DATA fileinfo;
		HANDLE hFile = FindFirstFile( filename.c_str(), &fileinfo);
		if ( hFile <= 0)
			result = false;
		else
		{
			FILETIME timefile_wt = fileinfo.ftLastWriteTime;
			FindClose( hFile);

			hFile = FindFirstFile( xmlfile.c_str(), &fileinfo);
			if ( hFile <= 0)
			{
				result = false;
			}
			else
			{
				FILETIME orgifile_wt = fileinfo.ftLastWriteTime;
				FindClose( hFile);

				//SYSTEMTIME orgi_sys;
				//FileTimeToSystemTime( &orgifile_wt, &orgi_sys);
				//printf( "@@@ %d:%d:%d:%d:%d:%d\n", orgi_sys.wYear, orgi_sys.wMonth, orgi_sys.wDay, orgi_sys.wHour, orgi_sys.wMinute, orgi_sys.wSecond);

				//FileTimeToSystemTime( &timefile_wt, &orgi_sys);
				//printf( "$$$ %d:%d:%d:%d:%d:%d\n", orgi_sys.wYear, orgi_sys.wMonth, orgi_sys.wDay, orgi_sys.wHour, orgi_sys.wMinute, orgi_sys.wSecond);

				int r = CompareFileTime( &orgifile_wt, &timefile_wt);
				result = CompareFileTime( &orgifile_wt, &timefile_wt) < 0;
			}
		}
	}

	if ( !result)
	{
		CreateDirectory( timefilesPath.c_str(), NULL);
		DeleteFile( filename.c_str());

		FILE* file = NULL;
		fopen_s( &file, filename.c_str(), "w+");
		fclose( file);
	}

	return result;
}

int _tmain(int argc, _TCHAR* argv[])
{
	if( argc < 2)
	{
		if ( argc == 1)
			PrintUsage( argv[0]);
		return -1;
	}
	
	const char*	szMode = "f";
	const char*	szXML = NULL;
	const char* szOut = ".";
	const char* szInlOut = NULL;
	const char* szGXInc = "../../include/gxwindow/gxwindow.h";
	const char* szGXacpp = "";
	const char* szTextFormatXML = "";
	bool bAutoPtr = false;
	bool bPakMode = false;
	bool bXMLPrefix = false;
	std::string szFileNamePrefix = "";
	std::string szNamespace = "";
	std::string szTextResFile = "";
	std::string szTimeFile = "";
	int nGenerateMode = CGxWEncoder::eGenMode_Code;

	for( int i = 1; i < argc; i ++)
	{
		char* szValue = argv[i];
		if( '-' != szValue[0] && '/' != szValue[0])
		{
			if( szXML)
			{
				PrintUsage( argv[0]);
				return -1;
			}
			szXML = szValue;
			continue;
		}
		szValue ++;
		if( 0 == szValue[0])
		{
			PrintUsage( argv[0]);
			return -1;
		}
		//if( szValue[1])
		//{
		//	PrintUsage( argv[0]);
		//	return -1;
		//}
		i ++;
		if( i >= argc && ( _stricmp( szValue, "autoptr") != 0) && (_stricmp( szValue, "p") != 0 || _stricmp( szValue, "P") != 0)
			 && (_stricmp( szValue, "f") != 0 || _stricmp( szValue, "F") != 0) )
		{
			PrintUsage( argv[0]);
			return -1;
		}

		switch( szValue[0])
		{
		case 'm':
		case 'M':
			szMode = argv[i];
			break;
		case 'o':
		case 'O':
			szOut = argv[i];
			break;
		case 'l':
		case 'L':
			szInlOut = argv[i];
			break;
		case 'i':
		case 'I':
			szGXInc = argv[i];
			break;
		case 'f':
		case 'F':
			bXMLPrefix = true;
			i --;
			break;
		case 'p':
		case 'P':
			bPakMode = true;
			i --;
			break;
		case 't':
		case 'T':
			szTextFormatXML = argv[i];
			break;
		case 'g':
		case 'G':
			{
				std::string option = argv[ i];
				if ( 0 == _stricmp( option.c_str(), "code"))
					nGenerateMode = CGxWEncoder::eGenMode_Code;
				else if ( 0 == _stricmp( option.c_str(), "frame"))
					nGenerateMode = CGxWEncoder::eGenMode_Frame;
				else if ( 0 == _stricmp( option.c_str(), "both"))
					nGenerateMode = CGxWEncoder::eGenMode_Both;
				else
				{
					PrintUsage( argv[0]);
					return -1;
				}
			}
			break;
		case 'c':
		case 'C':
			szTimeFile = argv[i];
			break;
		default:
			{
				if ( _stricmp( szValue, "acpp") == 0)
				{
					szGXacpp = argv[i];
					break;
				}
				if ( _stricmp( szValue, "autoptr") == 0)
				{
					bAutoPtr = true;
					i --;
					break;
				}
				if ( _stricmp( szValue, "namespace") == 0)
				{
					szNamespace = argv[i];
					break;
				}
				if ( _stricmp( szValue, "res") == 0)
				{
					szTextResFile = argv[i];
					break;
				}
			}
			PrintUsage( argv[0]);
			return -1;
		}
	} // for( int i = 1; i < argc; i ++)

	if( NULL == szXML)
	{
		PrintUsage( argv[0]);
		return -1;
	}
	if( 0 == szMode[0])
	{
		PrintUsage( argv[0]);
		return -1;
	}
	if( szMode[1])
	{
		PrintUsage( argv[0]);
		return -1;
	}
	bool bModeFile = true;
	switch( szMode[0])
	{
	case 'f':
	case 'F':
		bModeFile = true;
		break;
	case 'D':
	case 'd':
		bModeFile = false;
		break;
	default:
		PrintUsage( argv[0]);
		return -1;
	}

	if ( NULL == szInlOut)
		szInlOut = szOut;

	DWORD dwAttr = GetFileAttributes( szOut);
	if( -1 == dwAttr)
	{
		printf( "out directory not existing!\n");
		return -2;
	}
	if( FILE_ATTRIBUTE_DIRECTORY != ( dwAttr & FILE_ATTRIBUTE_DIRECTORY))
	{
		printf( "output not a directory!\n");
		return -3;
	}

	CreateDirectory( szInlOut, NULL);

	if ( !szTimeFile.empty() && CheckXmlFileTime( szXML, szTimeFile))
	{
		printf( "ui file<%s> has no change. Skipped!\n", szXML);
		return 0;
	}

	if ( bXMLPrefix )
	{
		std::string strPrefix = szXML;
		size_t pos1 = strPrefix.find_last_of( "\\/");
		size_t pos2 = strPrefix.find_last_of( ".");
		if ( pos1 == std::string::npos)
			szFileNamePrefix = strPrefix.substr( 0, pos2);
		else if ( pos2 > pos1)
			szFileNamePrefix = strPrefix.substr( pos1 + 1, pos2 - pos1 - 1);
	}

	g_gxwencoder.SetXmlFileName( szXML);
	g_gxwencoder.SetOutputPath( szOut);
	g_gxwencoder.SetInlFilePath( szInlOut);
	g_gxwencoder.SetIncludeFiles( szGXInc);
	g_gxwencoder.SetCppAppandCode( szGXacpp);
	g_gxwencoder.SetCreateAutoPtr( bAutoPtr);
	g_gxwencoder.SetPackMode( bPakMode);
	g_gxwencoder.SetFileNamePrefix( szFileNamePrefix);
	g_gxwencoder.SetTextFormatFile( szTextFormatXML);
	g_gxwencoder.SetNamespaces( szNamespace);
	g_gxwencoder.SetTextResXmlFile( szTextResFile);
	g_gxwencoder.SetGenMode( nGenerateMode);

	if ( bModeFile)
		return OutPutFile();
	else
		return OutPutPath( szXML);
}

