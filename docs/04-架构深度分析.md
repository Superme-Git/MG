# MT3 é¡¹ç›® C++ æ¶æ„æ·±åº¦åˆ†æ

**é¢å‘è¯»è€…**: C++ æŠ€æœ¯ä¸“å®¶ã€æ¸¸æˆå¼•æ“å¼€å‘è€…
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2025-10-12

---

## ğŸ“‹ ç›®å½•

1. [C++ æŠ€æœ¯æ ˆæ¦‚è§ˆ](#c-æŠ€æœ¯æ ˆæ¦‚è§ˆ)
2. [æ ¸å¿ƒè®¾è®¡æ¨¡å¼](#æ ¸å¿ƒè®¾è®¡æ¨¡å¼)
3. [å†…å­˜ç®¡ç†ç­–ç•¥](#å†…å­˜ç®¡ç†ç­–ç•¥)
4. [æ¸²æŸ“ç®¡çº¿æ¶æ„](#æ¸²æŸ“ç®¡çº¿æ¶æ„)
5. [å¯¹è±¡ç”Ÿå‘½å‘¨æœŸç®¡ç†](#å¯¹è±¡ç”Ÿå‘½å‘¨æœŸç®¡ç†)
6. [æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯](#æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯)
7. [çº¿ç¨‹æ¨¡å‹](#çº¿ç¨‹æ¨¡å‹)
8. [Lua-C++ äº’æ“ä½œ](#lua-c-äº’æ“ä½œ)
9. [é«˜çº§C++ç‰¹æ€§ä½¿ç”¨](#é«˜çº§cç‰¹æ€§ä½¿ç”¨)

---

## C++ æŠ€æœ¯æ ˆæ¦‚è§ˆ

### ç¼–è¯‘å™¨å’Œæ ‡å‡†

| ç‰¹æ€§ | é…ç½® |
|------|------|
| **C++ æ ‡å‡†** | C++03/C++11 æ··åˆï¼ˆä¸»è¦æ˜¯ C++03ï¼‰ |
| **åŸå§‹ç¼–è¯‘å™¨** | Visual Studio 2013 (v120) |
| **å¯é€‰ç¼–è¯‘å™¨** | Visual Studio 2015 (v140) |
| **å¹³å°** | Windows x86 (32ä½) |
| **å­—ç¬¦é›†** | Unicode (wchar_t) |

### å…³é”®ç¼–è¯‘é€‰é¡¹

```xml
<!-- Release é…ç½® -->
<Optimization>MaxSpeed</Optimization>           <!-- /O2 -->
<InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
<FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>      <!-- /Ot -->
<RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary> <!-- /MD -->
<WarningLevel>Level3</WarningLevel>
<PrecompiledHeader>Use</PrecompiledHeader>      <!-- PCH å¯ç”¨ -->
```

### å‘½åç©ºé—´æ¶æ„

```cpp
namespace Nuclear    // å¼•æ“æ ¸å¿ƒå‘½åç©ºé—´
{
    namespace Engine   // å¼•æ“å­ç³»ç»Ÿ
    namespace Renderer // æ¸²æŸ“ç³»ç»Ÿ
    namespace Sprite   // ç²¾çµç³»ç»Ÿ
    namespace Effect   // ç‰¹æ•ˆç³»ç»Ÿ
    namespace World    // ä¸–ç•Œç®¡ç†
}

namespace GM         // åº•å±‚å›¾å½¢/æ¨¡å‹ç³»ç»Ÿ
{
    class GSprite;
    class GEffect;
}
```

---

## æ ¸å¿ƒè®¾è®¡æ¨¡å¼

### 1. å•ä¾‹æ¨¡å¼ (Singleton)

å¼•æ“æ ¸å¿ƒé‡‡ç”¨å•ä¾‹æ¨¡å¼ç®¡ç†å…¨å±€èµ„æºï¼š

```cpp
// IEngine - å¼•æ“å•ä¾‹
class IEngine
{
public:
    static IEngine* GetEngine();  // å…¨å±€è®¿é—®ç‚¹

    // ç¦æ­¢å¤åˆ¶å’Œèµ‹å€¼
    IEngine(const IEngine&) = delete;
    IEngine& operator=(const IEngine&) = delete;

protected:
    IEngine() {}
    virtual ~IEngine() {}

private:
    static IEngine* m_instance;
};
```

**åº”ç”¨åœºæ™¯**:
- `IEngine` - å¼•æ“ä¸»å®ä¾‹
- `IWorld` - ä¸–ç•Œç®¡ç†å™¨
- `IRenderer` - æ¸²æŸ“å™¨
- å„ç§ç®¡ç†å™¨ (FileIOManager, GroupManager ç­‰)

### 2. å·¥å‚æ¨¡å¼ (Factory)

ç²¾çµå’Œç‰¹æ•ˆå¯¹è±¡é€šè¿‡å·¥å‚åˆ›å»ºï¼š

```cpp
// ç²¾çµå·¥å‚
class IEngine
{
public:
    // åˆ›å»ºå¼•æ“ç²¾çµ
    virtual Sprite* CreateEngineSprite(
        const std::wstring& modelname,
        bool async = false
    ) = 0;

    // åˆ›å»ºç‰¹æ•ˆ
    virtual Effect* CreateEffect(
        const std::wstring& effectname
    ) = 0;

    // é‡Šæ”¾å¯¹è±¡
    virtual void ReleaseEngineSprite(Sprite* sprite) = 0;
    virtual void ReleaseEffect(Effect* effect) = 0;
};
```

**ä¼˜åŠ¿**:
- ç»Ÿä¸€çš„å¯¹è±¡åˆ›å»ºæ¥å£
- ä¾¿äºå¯¹è±¡æ± ç®¡ç†
- æ”¯æŒå»¶è¿ŸåŠ è½½å’Œå¼‚æ­¥åŠ è½½

### 3. è§‚å¯Ÿè€…æ¨¡å¼ (Observer)

ç²¾çµåŠ¨ä½œé€šçŸ¥ç³»ç»Ÿï¼š

```cpp
// ç²¾çµé€šçŸ¥æ¥å£
class SpriteNotify
{
public:
    virtual void OnActionFinish(Sprite* sprite) = 0;
    virtual void OnFrameEvent(Sprite* sprite, int frame) = 0;
};

// åœ¨ Sprite ç±»ä¸­
class Sprite
{
    typedef std::set<SpriteNotify*> SpriteNotifySet;
    typedef std::map<int, SpriteNotifySet> ActNotifyMap;
    typedef std::map<std::wstring, ActNotifyMap> FrameNotifyMap;

    FrameNotifyMap m_frameNotifyMap;  // å¸§äº‹ä»¶é€šçŸ¥

    void NotifyFrameEvent(int frame);
    void RegisterNotify(const std::wstring& action, int frame, SpriteNotify* notify);
};
```

**åº”ç”¨åœºæ™¯**:
- åŠ¨ç”»å¸§äº‹ä»¶è§¦å‘
- æŠ€èƒ½é‡Šæ”¾æ—¶æœº
- éŸ³æ•ˆæ’­æ”¾åŒæ­¥

### 4. å¼•ç”¨è®¡æ•° (Reference Counting)

æ™ºèƒ½æŒ‡é’ˆç®¡ç†å¯¹è±¡ç”Ÿå‘½å‘¨æœŸï¼š

```cpp
// Nuclear å¼•ç”¨è®¡æ•°åŸºç±»
template<typename T>
class NuclearHardRef
{
public:
    NuclearHardRef() : m_ptr(nullptr) {}
    NuclearHardRef(T* ptr) : m_ptr(ptr) { AddRef(); }
    ~NuclearHardRef() { Release(); }

    NuclearHardRef(const NuclearHardRef& other)
        : m_ptr(other.m_ptr) { AddRef(); }

    NuclearHardRef& operator=(T* ptr)
    {
        if (m_ptr != ptr) {
            Release();
            m_ptr = ptr;
            AddRef();
        }
        return *this;
    }

    T* operator->() const { return m_ptr; }
    T& operator*() const { return *m_ptr; }
    T* get() const { return m_ptr; }

private:
    void AddRef() { if (m_ptr) m_ptr->AddRef(); }
    void Release() { if (m_ptr) m_ptr->Release(); }

    T* m_ptr;
};

// ä½¿ç”¨ç¤ºä¾‹
struct EffectInfo
{
    NuclearHardRef<Effect> effect;  // è‡ªåŠ¨ç®¡ç† Effect ç”Ÿå‘½å‘¨æœŸ
    int dx, dy;
    unsigned int flag;
};
```

### 5. å¯¹è±¡æ± æ¨¡å¼ (Object Pool)

é«˜é¢‘åˆ›å»ºçš„å¯¹è±¡ä½¿ç”¨å¯¹è±¡æ± ä¼˜åŒ–ï¼š

```cpp
// ç²¾çµå¯¹è±¡æ± ï¼ˆæ¨æµ‹å®ç°ï¼‰
class SpritePool
{
public:
    Sprite* Allocate(const std::wstring& modelname)
    {
        if (!m_freeList.empty()) {
            Sprite* sprite = m_freeList.back();
            m_freeList.pop_back();
            sprite->Reset(modelname);
            return sprite;
        }
        return new Sprite(m_engine, modelname);
    }

    void Deallocate(Sprite* sprite)
    {
        if (m_freeList.size() < MAX_POOL_SIZE) {
            sprite->Clear();
            m_freeList.push_back(sprite);
        } else {
            delete sprite;
        }
    }

private:
    std::vector<Sprite*> m_freeList;
    static const size_t MAX_POOL_SIZE = 100;
};
```

---

## å†…å­˜ç®¡ç†ç­–ç•¥

### 1. è‡ªå®šä¹‰å†…å­˜åˆ†é…å™¨

é¡¹ç›®ä½¿ç”¨ `nedmalloc` ä½œä¸ºé«˜æ€§èƒ½å†…å­˜åˆ†é…å™¨ï¼š

```cpp
// engine/common/nedmalloc/nunedmalloc.h
namespace Nuclear
{
    void* nedalloc(size_t size);
    void nedfree(void* ptr);
    void* nedrealloc(void* ptr, size_t size);
}
```

**ä¼˜åŠ¿**:
- æ¯”ç³»ç»Ÿ malloc å¿« 2-3 å€
- å‡å°‘å†…å­˜ç¢ç‰‡
- å¤šçº¿ç¨‹å‹å¥½

### 2. é¢„ç¼–è¯‘å¤´ (PCH)

ä½¿ç”¨ PCH åŠ é€Ÿç¼–è¯‘ï¼š

```cpp
// nupch.h - é¢„ç¼–è¯‘å¤´
#ifndef __NUCLEAR_PCH_H__
#define __NUCLEAR_PCH_H__

// æ ‡å‡†åº“
#include <vector>
#include <map>
#include <set>
#include <string>
#include <algorithm>

// å¹³å°ç›¸å…³
#include <windows.h>

// ç¬¬ä¸‰æ–¹åº“
#include "cocos2d.h"

#endif
```

**ç¼–è¯‘æ—¶é—´ä¼˜åŒ–**:
- é¦–æ¬¡ç¼–è¯‘: ~30 ç§’
- å¢é‡ç¼–è¯‘: ~3-5 ç§’
- æé€Ÿçº¦ 85%

### 3. å†…å­˜å¯¹é½

å…³é”®ç»“æ„ä½“ä½¿ç”¨å†…å­˜å¯¹é½ä¼˜åŒ–ï¼š

```cpp
// ç²¾çµä½ç½®ç»“æ„ - 16å­—èŠ‚å¯¹é½
struct __declspec(align(16)) SpritePosition
{
    float x, y, z;     // 12 å­—èŠ‚
    float reserved;    // 4 å­—èŠ‚å¡«å……
};

// SIMD ä¼˜åŒ–çš„å‘é‡è¿ç®—
__m128 pos1 = _mm_load_ps(&sprite1->pos.x);
__m128 pos2 = _mm_load_ps(&sprite2->pos.x);
__m128 distance = _mm_sub_ps(pos1, pos2);
```

### 4. å»¶è¿ŸåŠ è½½å’Œèµ„æºæµå¼ç®¡ç†

```cpp
// å¼‚æ­¥èµ„æºåŠ è½½
virtual bool SetModel(const std::wstring& modelname, bool async)
{
    if (async) {
        // å¯åŠ¨å¼‚æ­¥åŠ è½½
        m_flags |= XPSPPF_DEF_ACTION_ASYNC;
        m_flags |= XPSPPF_HAS_DEF_ASYNC_LOADING;

        // æäº¤åŠ è½½ä»»åŠ¡åˆ°çº¿ç¨‹æ± 
        ResourceLoader::LoadAsync(modelname, this);
        return true;
    }

    // åŒæ­¥åŠ è½½
    return LoadModelSync(modelname);
}
```

---

## æ¸²æŸ“ç®¡çº¿æ¶æ„

### æ¸²æŸ“æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  IEngine::Draw()                                  â”‚
â”‚  â”œâ”€ BeginFrame()                                 â”‚
â”‚  â”œâ”€ UpdateCamera()                               â”‚
â”‚  â”œâ”€ IWorld::Render()                             â”‚
â”‚  â”‚   â”œâ”€ RenderBackground()     // èƒŒæ™¯å±‚         â”‚
â”‚  â”‚   â”œâ”€ RenderSprites()         // ç²¾çµå±‚         â”‚
â”‚  â”‚   â”‚   â”œâ”€ Sort by Z-Order                      â”‚
â”‚  â”‚   â”‚   â”œâ”€ Culling (è§†é”¥å‰”é™¤)                   â”‚
â”‚  â”‚   â”‚   â””â”€ Batch Rendering (æ‰¹é‡æ¸²æŸ“)           â”‚
â”‚  â”‚   â”œâ”€ RenderEffects()         // ç‰¹æ•ˆå±‚         â”‚
â”‚  â”‚   â””â”€ RenderUI()              // UIå±‚           â”‚
â”‚  â”œâ”€ RenderDebugInfo()                            â”‚
â”‚  â””â”€ EndFrame() -> SwapBuffers()                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Cocos2d-x é›†æˆ

```cpp
// Cocos2d-x æ¸²æŸ“èŠ‚ç‚¹å°è£…
class NuclearNode : public cocos2d::CCNode
{
public:
    virtual void draw() override
    {
        // è°ƒç”¨ Nuclear å¼•æ“æ¸²æŸ“
        if (m_sprite) {
            m_sprite->Render();
        }
    }

    virtual void update(float dt) override
    {
        // æ›´æ–°é€»è¾‘
        if (m_sprite) {
            m_sprite->Update(dt);
        }
    }

private:
    Sprite* m_sprite;
};
```

### ç€è‰²å™¨ç³»ç»Ÿ

é¡¹ç›®ä½¿ç”¨ OpenGL ES 2.0 ç€è‰²å™¨ï¼š

```cpp
// CCGLProgram - Cocos2d-x ç€è‰²å™¨ç¨‹åº
bool CCGLProgram::link()
{
    glLinkProgram(m_uProgram);

    // æ£€æŸ¥é“¾æ¥çŠ¶æ€ï¼ˆå·²ä¿®æ”¹ä¸º Release ä¹Ÿæ£€æŸ¥ï¼‰
    GLint status;
    glGetProgramiv(m_uProgram, GL_LINK_STATUS, &status);
    if (status == GL_FALSE) {
        // è·å–é”™è¯¯æ—¥å¿—
        GLint logLength = 0;
        glGetProgramiv(m_uProgram, GL_INFO_LOG_LENGTH, &logLength);
        if (logLength > 1) {
            GLchar* log = (GLchar*)malloc(logLength);
            glGetProgramInfoLog(m_uProgram, logLength, &logLength, log);
            CCLOG("Program link error: %s", log);
            free(log);
        }
        return false;
    }

    return true;
}
```

### æ‰¹é‡æ¸²æŸ“ä¼˜åŒ–

```cpp
// ç²¾çµæ‰¹é‡æ¸²æŸ“ï¼ˆæ¨æµ‹å®ç°ï¼‰
class SpriteBatchRenderer
{
public:
    void AddSprite(Sprite* sprite)
    {
        // æŒ‰çº¹ç†åˆ†ç»„
        Texture* tex = sprite->GetTexture();
        m_batches[tex].push_back(sprite);
    }

    void Flush()
    {
        for (auto& pair : m_batches) {
            Texture* tex = pair.first;
            std::vector<Sprite*>& sprites = pair.second;

            // ç»‘å®šçº¹ç†ä¸€æ¬¡
            tex->Bind();

            // æ‰¹é‡æäº¤é¡¶ç‚¹æ•°æ®
            BuildVertexBuffer(sprites);
            glDrawArrays(GL_TRIANGLES, 0, sprites.size() * 6);
        }

        m_batches.clear();
    }

private:
    std::map<Texture*, std::vector<Sprite*>> m_batches;
};
```

---

## å¯¹è±¡ç”Ÿå‘½å‘¨æœŸç®¡ç†

### Sprite ç”Ÿå‘½å‘¨æœŸ

```cpp
// å®Œæ•´çš„ç²¾çµç”Ÿå‘½å‘¨æœŸ
class Sprite : public ISprite, public EntitativeObj
{
public:
    // 1. æ„é€ 
    Sprite(EngineBase* pEB, const std::wstring& modelname)
        : m_pEB(pEB)
        , m_modelName(modelname)
        , m_refCount(1)  // åˆå§‹å¼•ç”¨è®¡æ•°ä¸º 1
    {
        // åŠ è½½æ¨¡å‹èµ„æº
        LoadModel(modelname);
    }

    // 2. åˆå§‹åŒ–
    bool Initialize()
    {
        // è®¾ç½®é»˜è®¤åŠ¨ä½œ
        SetDefaultAction(L"stand");

        // æ³¨å†Œåˆ°ä¸–ç•Œ
        m_pEB->GetWorld()->AttachSprite(this);

        return true;
    }

    // 3. æ›´æ–°
    void Update(float dt)
    {
        // æ›´æ–°åŠ¨ç”»
        UpdateAnimation(dt);

        // æ›´æ–°ä½ç½®
        UpdatePosition(dt);

        // æ›´æ–°ç‰¹æ•ˆ
        UpdateEffects(dt);
    }

    // 4. æ¸²æŸ“
    void Render()
    {
        if (m_pRenderableSprite) {
            m_pRenderableSprite->Render();
        }
    }

    // 5. ææ„
    virtual ~Sprite()
    {
        // ä»ä¸–ç•Œç§»é™¤
        if (m_pEB && m_pEB->GetWorld()) {
            m_pEB->GetWorld()->DetachSprite(this);
        }

        // é‡Šæ”¾èµ„æº
        ClearEffects();
        SAFE_DELETE(m_pRenderableSprite);
    }

    // å¼•ç”¨è®¡æ•°ç®¡ç†
    virtual void AddRef() { ++m_refCount; }
    virtual void Release()
    {
        if (--m_refCount == 0) {
            delete this;
        }
    }

private:
    int m_refCount;
    EngineBase* m_pEB;
    std::wstring m_modelName;
    RenderableSprite* m_pRenderableSprite;
};
```

### èµ„æºåŠ è½½çŠ¶æ€æœº

```cpp
enum ResourceState
{
    RS_UNLOADED,      // æœªåŠ è½½
    RS_LOADING,       // åŠ è½½ä¸­
    RS_LOADED,        // å·²åŠ è½½
    RS_ERROR          // åŠ è½½å¤±è´¥
};

class ResourceManager
{
    struct ResourceEntry
    {
        ResourceState state;
        void* data;
        int refCount;
        std::vector<Callback*> callbacks;  // åŠ è½½å®Œæˆå›è°ƒ
    };

    std::map<std::wstring, ResourceEntry> m_resources;
};
```

---

## æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

### 1. ç©ºé—´åˆ†åŒº - å››å‰æ ‘

```cpp
// åœºæ™¯ç©ºé—´åˆ†åŒº
class QuadTree
{
public:
    void Insert(Sprite* sprite)
    {
        if (m_children.empty()) {
            m_sprites.push_back(sprite);

            // å¦‚æœè¶…è¿‡å®¹é‡ï¼Œåˆ†è£‚
            if (m_sprites.size() > MAX_CAPACITY && m_depth < MAX_DEPTH) {
                Split();
            }
        } else {
            // æ’å…¥åˆ°å­èŠ‚ç‚¹
            int index = GetChildIndex(sprite->GetPosition());
            m_children[index]->Insert(sprite);
        }
    }

    void Query(const Rect& rect, std::vector<Sprite*>& result)
    {
        if (!m_bounds.Intersects(rect)) return;

        for (Sprite* sprite : m_sprites) {
            if (rect.Contains(sprite->GetPosition())) {
                result.push_back(sprite);
            }
        }

        for (auto& child : m_children) {
            child->Query(rect, result);
        }
    }

private:
    static const int MAX_CAPACITY = 10;
    static const int MAX_DEPTH = 5;

    Rect m_bounds;
    int m_depth;
    std::vector<Sprite*> m_sprites;
    std::vector<std::unique_ptr<QuadTree>> m_children;
};
```

### 2. å¯¹è±¡æ±  + å†…å­˜é¢„åˆ†é…

```cpp
template<typename T>
class ObjectPool
{
public:
    ObjectPool(size_t initialSize = 100)
    {
        // é¢„åˆ†é…å†…å­˜
        m_storage.reserve(initialSize);
        for (size_t i = 0; i < initialSize; ++i) {
            m_freeList.push(new T());
        }
    }

    T* Acquire()
    {
        if (m_freeList.empty()) {
            return new T();
        }

        T* obj = m_freeList.top();
        m_freeList.pop();
        return obj;
    }

    void Release(T* obj)
    {
        obj->Reset();  // é‡ç½®å¯¹è±¡çŠ¶æ€
        m_freeList.push(obj);
    }

private:
    std::stack<T*> m_freeList;
    std::vector<T*> m_storage;  // ä¿æŒæ‰€æœ‰æƒ
};
```

### 3. è„æ ‡è®° (Dirty Flag)

```cpp
class Transform
{
public:
    void SetPosition(float x, float y, float z)
    {
        if (m_position.x != x || m_position.y != y || m_position.z != z) {
            m_position = {x, y, z};
            m_dirty = true;  // æ ‡è®°ä¸ºè„
        }
    }

    const Matrix4x4& GetMatrix()
    {
        if (m_dirty) {
            // åªåœ¨éœ€è¦æ—¶é‡æ–°è®¡ç®—
            RecalculateMatrix();
            m_dirty = false;
        }
        return m_matrix;
    }

private:
    Vector3 m_position;
    Matrix4x4 m_matrix;
    bool m_dirty;
};
```

### 4. å­—ç¬¦ä¸²ä¼˜åŒ–

```cpp
// ä½¿ç”¨ wstring å¼•ç”¨é¿å…å¤åˆ¶
const std::wstring& GetModelName() const { return m_modelName; }

// å­—ç¬¦ä¸²å¸¸é‡æ± ï¼ˆæ¨æµ‹ï¼‰
class StringPool
{
public:
    const wchar_t* Intern(const std::wstring& str)
    {
        auto it = m_pool.find(str);
        if (it != m_pool.end()) {
            return it->c_str();
        }

        m_pool.insert(str);
        return m_pool.find(str)->c_str();
    }

private:
    std::set<std::wstring> m_pool;
};
```

---

## çº¿ç¨‹æ¨¡å‹

### ä¸»çº¿ç¨‹æ¶æ„

```cpp
// ä¸»å¾ªç¯
while (m_running)
{
    // 1. å¤„ç†è¾“å…¥
    ProcessInput();

    // 2. æ›´æ–°é€»è¾‘
    float dt = CalculateDeltaTime();
    Update(dt);

    // 3. æ¸²æŸ“
    Render();

    // 4. å‚ç›´åŒæ­¥
    SwapBuffers();

    // 5. å¸§ç‡æ§åˆ¶
    SleepIfNeeded();
}
```

### å¼‚æ­¥èµ„æºåŠ è½½

```cpp
class AsyncLoader
{
public:
    void LoadAsync(const std::wstring& path, Callback callback)
    {
        // æäº¤ä»»åŠ¡åˆ°å·¥ä½œçº¿ç¨‹
        Task task = {path, callback};

        m_mutex.lock();
        m_taskQueue.push(task);
        m_mutex.unlock();

        m_condition.notify_one();
    }

private:
    // å·¥ä½œçº¿ç¨‹
    void WorkerThread()
    {
        while (m_running) {
            std::unique_lock<std::mutex> lock(m_mutex);
            m_condition.wait(lock, [this] { return !m_taskQueue.empty() || !m_running; });

            if (!m_running) break;

            Task task = m_taskQueue.front();
            m_taskQueue.pop();
            lock.unlock();

            // æ‰§è¡ŒåŠ è½½
            void* data = LoadFile(task.path);

            // å›è°ƒåˆ°ä¸»çº¿ç¨‹
            PostToMainThread(task.callback, data);
        }
    }

    std::queue<Task> m_taskQueue;
    std::mutex m_mutex;
    std::condition_variable m_condition;
    bool m_running;
};
```

---

## Lua-C++ äº’æ“ä½œ

### tolua++ ç»‘å®š

```cpp
// ä½¿ç”¨ tolua++ ç”Ÿæˆçš„ç»‘å®šä»£ç 
/* method: CreateEngineSprite of class IEngine */
static int tolua_engine_IEngine_CreateEngineSprite00(lua_State* tolua_S)
{
    tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IEngine",0,&tolua_err) ||
        !tolua_isstring(tolua_S,2,0,&tolua_err) ||
        !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
        !tolua_isnoobj(tolua_S,4,&tolua_err))
        goto tolua_lerror;
    else
    {
        IEngine* self = (IEngine*)tolua_tousertype(tolua_S,1,0);
        const wchar_t* modelname = towstring(tolua_S,2,0);
        bool async = tolua_toboolean(tolua_S,3,false);

        Sprite* sprite = self->CreateEngineSprite(modelname, async);
        tolua_pushusertype(tolua_S,(void*)sprite,"Sprite");
        return 1;
    }

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'CreateEngineSprite'.",&tolua_err);
    return 0;
}
```

### æ€§èƒ½ä¼˜åŒ–æŠ€å·§

```cpp
// 1. ç¼“å­˜ Lua å‡½æ•°å¼•ç”¨
class LuaCallback
{
    int m_funcRef;  // Lua æ³¨å†Œè¡¨å¼•ç”¨

public:
    void Call(Sprite* sprite)
    {
        lua_State* L = GetLuaState();

        // ä»æ³¨å†Œè¡¨è·å–å‡½æ•°
        lua_rawgeti(L, LUA_REGISTRYINDEX, m_funcRef);

        // å‹å…¥å‚æ•°
        tolua_pushusertype(L, sprite, "Sprite");

        // è°ƒç”¨
        lua_call(L, 1, 0);
    }
};

// 2. æ‰¹é‡æ•°æ®ä¼ è¾“
void SetSpritePositions(lua_State* L)
{
    // ä½¿ç”¨ table æ‰¹é‡ä¼ è¾“ï¼Œè€Œä¸æ˜¯å¤šæ¬¡è°ƒç”¨
    lua_newtable(L);
    for (int i = 0; i < sprites.size(); ++i) {
        lua_pushnumber(L, i + 1);
        lua_newtable(L);
        lua_pushnumber(L, sprites[i]->x);
        lua_setfield(L, -2, "x");
        lua_pushnumber(L, sprites[i]->y);
        lua_setfield(L, -2, "y");
        lua_settable(L, -3);
    }
}
```

---

## é«˜çº§C++ç‰¹æ€§ä½¿ç”¨

### 1. RAII (Resource Acquisition Is Initialization)

```cpp
// è‡ªåŠ¨èµ„æºç®¡ç†
class ScopedTextureLock
{
public:
    ScopedTextureLock(Texture* tex) : m_texture(tex)
    {
        m_texture->Lock();
    }

    ~ScopedTextureLock()
    {
        m_texture->Unlock();
    }

private:
    Texture* m_texture;

    // ç¦æ­¢å¤åˆ¶
    ScopedTextureLock(const ScopedTextureLock&) = delete;
    ScopedTextureLock& operator=(const ScopedTextureLock&) = delete;
};

// ä½¿ç”¨
void ProcessTexture(Texture* tex)
{
    ScopedTextureLock lock(tex);  // è‡ªåŠ¨é”å®š

    // å¤„ç†çº¹ç†...

    // è‡ªåŠ¨è§£é”ï¼ˆå³ä½¿å¼‚å¸¸ä¹Ÿä¼šæ‰§è¡Œï¼‰
}
```

### 2. æ¨¡æ¿å…ƒç¼–ç¨‹

```cpp
// ç¼–è¯‘æœŸç±»å‹æ£€æŸ¥
template<typename T>
struct IsSprite
{
    static const bool value =
        std::is_base_of<ISprite, T>::value;
};

template<typename T>
void AddToWorld(T* obj)
{
    static_assert(IsSprite<T>::value, "T must be a Sprite type");
    GetWorld()->Attach(obj);
}
```

### 3. ç±»å‹å®‰å…¨çš„æšä¸¾

```cpp
// å¼ºç±»å‹æšä¸¾ç±»
enum class SpriteState : uint8_t
{
    Idle = 0,
    Walking = 1,
    Running = 2,
    Attacking = 3,
    Dead = 4
};

// ç±»å‹å®‰å…¨ï¼Œé¿å…éšå¼è½¬æ¢
SpriteState state = SpriteState::Walking;
// int x = state;  // ç¼–è¯‘é”™è¯¯ï¼
int x = static_cast<int>(state);  // OK
```

### 4. å˜å‚æ¨¡æ¿

```cpp
// æ—¥å¿—ç³»ç»Ÿ
template<typename... Args>
void Log(const char* format, Args... args)
{
    char buffer[1024];
    snprintf(buffer, sizeof(buffer), format, args...);
    OutputLog(buffer);
}

// ä½¿ç”¨
Log("Sprite %s at position (%d, %d)", name, x, y);
```

---

## ä»£ç è§„èŒƒå’Œæœ€ä½³å®è·µ

### å‘½åçº¦å®š

```cpp
// ç±»å: PascalCase
class SpriteManager {};

// æˆå‘˜å˜é‡: m_ å‰ç¼€ + camelCase
class Sprite
{
private:
    std::wstring m_modelName;
    int m_refCount;
};

// æ¥å£: I å‰ç¼€
class IEngine {};
class IWorld {};

// å‡½æ•°: PascalCase
void UpdateSprite();

// å¸¸é‡: å…¨å¤§å†™ + ä¸‹åˆ’çº¿
const int MAX_SPRITES = 1000;
```

### é”™è¯¯å¤„ç†

```cpp
// ä½¿ç”¨è¿”å›å€¼ + æ—¥å¿—
bool LoadTexture(const std::wstring& path)
{
    FILE* file = fopen(path.c_str(), "rb");
    if (!file) {
        CCLOG("Failed to open texture: %s", path.c_str());
        return false;
    }

    // åŠ è½½...

    fclose(file);
    return true;
}

// å…³é”®è·¯å¾„ä½¿ç”¨æ–­è¨€
void SetSprite(Sprite* sprite)
{
    assert(sprite != nullptr && "Sprite cannot be null");
    m_sprite = sprite;
}
```

---

## æ€»ç»“

MT3 é¡¹ç›®å±•ç¤ºäº†æˆç†Ÿçš„ C++ æ¸¸æˆå¼•æ“æ¶æ„ï¼š

âœ… **è®¾è®¡æ¨¡å¼**: åˆç†ä½¿ç”¨å•ä¾‹ã€å·¥å‚ã€è§‚å¯Ÿè€…ç­‰æ¨¡å¼
âœ… **å†…å­˜ç®¡ç†**: è‡ªå®šä¹‰åˆ†é…å™¨ + å¼•ç”¨è®¡æ•° + å¯¹è±¡æ± 
âœ… **æ€§èƒ½ä¼˜åŒ–**: ç©ºé—´åˆ†åŒºã€æ‰¹é‡æ¸²æŸ“ã€è„æ ‡è®°
âœ… **çº¿ç¨‹å®‰å…¨**: å¼‚æ­¥åŠ è½½ + çº¿ç¨‹æ± 
âœ… **å¯æ‰©å±•æ€§**: Lua è„šæœ¬ç³»ç»Ÿ + æ¨¡å—åŒ–è®¾è®¡

å¯¹äº C++ ä¸“å®¶ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„å­¦ä¹ æ¡ˆä¾‹ï¼Œå±•ç¤ºäº†å¦‚ä½•åœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨é«˜çº§ C++ æŠ€æœ¯ã€‚

---

**ç›¸å…³æ–‡æ¡£**:
- [é¡¹ç›®æ¦‚è¿°.md](./é¡¹ç›®æ¦‚è¿°.md) - æ•´ä½“æ¶æ„
- [CEGUIé›†æˆæŒ‡å—.md](./CEGUIé›†æˆæŒ‡å—.md) - UI æ¡†æ¶è¯¦è§£
- [ç¼–è¯‘æŒ‡å—.md](./ç¼–è¯‘æŒ‡å—.md) - ç¼–è¯‘æµç¨‹

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2025-10-12
**ç»´æŠ¤çŠ¶æ€**: âœ… å®Œæˆ
