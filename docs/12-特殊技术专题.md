#ifndef __CCGL_H__
#define __CCGL_H__

#include "GL/glew.h"  // 使用原生 OpenGL

#define CC_GL_DEPTH24_STENCIL8    GL_DEPTH24_STENCIL8

#endif // __CCGL_H__

EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
eglInitialize(display, NULL, NULL);
// ... 更多 EGL 代码

// CEGUI 使用左上角为原点，需要转换到 Cocos2d-x 的左下角坐标系
cocos2d::CCPoint ConvertCEGUIToCocos2d(const CEGUI::Vector2& ceguiPos)
{
    // 获取屏幕高度
    float screenHeight = cocos2d::CCDirector::sharedDirector()->getWinSize().height;
    
    return cocos2d::CCPoint(
        ceguiPos.d_x,
        screenHeight - ceguiPos.d_y  // 翻转 Y 坐标
    );
}

// 二进制布局序列化器 (推测实现)
class CEGUIBinLayoutFileSerializer
{
public:
    void Serialize(const CEGUI::Window* window, const std::string& filename)
    {
        CEGUIFileStream stream(filename, CEGUIFileStream::Write);
        SerializeWindow(window, stream);
        stream.close();
    }

    CEGUI::Window* Deserialize(const std::string& filename)
    {
        CEGUIFileStream stream(filename, CEGUIFileStream::Read);
        CEGUI::Window* window = DeserializeWindow(stream);
        stream.close();
        return window;
    }

private:
    void SerializeWindow(const CEGUI::Window* window, CEGUIFileStream& stream);
    CEGUI::Window* DeserializeWindow(CEGUIFileStream& stream);
};

// CEGUI 初始化
void InitializeCEGUI()
{
    // 1. 创建渲染器
    CEGUI::CocosCEGUIRenderer& renderer =
        CEGUI::CocosCEGUIRenderer::create();
    
    // 2. 创建 CEGUI 系统
    CEGUI::System::create(renderer);
    
    // 3. 设置资源目录
    CEGUI::DefaultResourceProvider* rp =
        static_cast<CEGUI::DefaultResourceProvider*>(
            CEGUI::System::getSingleton().getResourceProvider());
    
    rp->setResourceGroupDirectory("schemes", "cegui/schemes/");
    rp->setResourceGroupDirectory("imagesets", "cegui/imagesets/");
    rp->setResourceGroupDirectory("fonts", "cegui/fonts/");
    rp->setResourceGroupDirectory("layouts", "cegui/layouts/");
    rp->setResourceGroupDirectory("looknfeels", "cegui/looknfeel/");
    
    // 4. 加载资源
    CEGUI::SchemeManager::getSingleton().create("MT3Scheme.scheme");
    CEGUI::FontManager::getSingleton().create("SimHei-14.font");
    CEGUI::System::getSingleton().setDefaultFont("SimHei-14");
    CEGUI::System::getSingleton().setDefaultMouseCursor("MT3Scheme", "MouseArrow");
    
    // 5. 设置根窗口
    CEGUI::Window* rootWindow = CEGUI::WindowManager::getSingleton()
        .createWindow("DefaultWindow", "Root");
    CEGUI::System::getSingleton().setGUISheet(rootWindow);
}

// UI 元素创建示例
CEGUI::Window* CreateLoginDialog()
{
    CEGUI::WindowManager& wmgr = CEGUI::WindowManager::getSingleton();
    
    // 创建主窗口
    CEGUI::FrameWindow* dialog = static_cast<CEGUI::FrameWindow*>(
        wmgr.createWindow("MT3Scheme/FrameWindow", "LoginDialog"));
    
    dialog->setPosition(CEGUI::UVector2(CEGUI::UDim(0.25f, 0), CEGUI::UDim(0.25f, 0)));
    dialog->setSize(CEGUI::UVector2(CEGUI::UDim(0.5f, 0), CEGUI::UDim(0.5f, 0)));
    dialog->setText("登录");
    
    // 用户名标签
    CEGUI::Window* usernameLabel = wmgr.createWindow("MT3Scheme/Label", "UsernameLabel");
    usernameLabel->setPosition(CEGUI::UVector2(CEGUI::UDim(0.1f, 0), CEGUI::UDim(0.2f, 0)));
    usernameLabel->setSize(CEGUI::UVector2(CEGUI::UDim(0.3f, 0), CEGUI::UDim(0.1f, 0)));
    usernameLabel->setText("用户名:");
    dialog->addChildWindow(usernameLabel);
    
    // 用户名输入框
    CEGUI::Editbox* usernameEdit = static_cast<CEGUI::Editbox*>(
        wmgr.createWindow("MT3Scheme/Editbox", "UsernameEdit"));
    usernameEdit->setPosition(CEGUI::UVector2(CEGUI::UDim(0.4f, 0), CEGUI::UDim(0.2f, 0)));
    usernameEdit->setSize(CEGUI::UVector2(CEGUI::UDim(0.5f, 0), CEGUI::UDim(0.1f, 0)));
    dialog->addChildWindow(usernameEdit);
    
    // 密码标签
    CEGUI::Window* passwordLabel = wmgr.createWindow("MT3Scheme/Label", "PasswordLabel");
    passwordLabel->setPosition(CEGUI::UVector2(CEGUI::UDim(0.1f, 0), CEGUI::UDim(0.35f, 0)));
    passwordLabel->setSize(CEGUI::UVector2(CEGUI::UDim(0.3f, 0), CEGUI::UDim(0.1f, 0)));
    passwordLabel->setText("密码:");
    dialog->addChildWindow(passwordLabel);
    
    // 密码输入框
    CEGUI::Editbox* passwordEdit = static_cast<CEGUI::Editbox*>(
        wmgr.createWindow("MT3Scheme/Editbox", "PasswordEdit"));
    passwordEdit->setPosition(CEGUI::UVector2(CEGUI::UDim(0.4f, 0), CEGUI::UDim(0.35f, 0)));
    passwordEdit->setSize(CEGUI::UVector2(CEGUI::UDim(0.5f, 0), CEGUI::UDim(0.1f, 0)));
    passwordEdit->setProperty("MaskText", "true");  // 密码遮罩
    dialog->addChildWindow(passwordEdit);
    
    // 登录按钮
    CEGUI::PushButton* loginButton = static_cast<CEGUI::PushButton*>(
        wmgr.createWindow("MT3Scheme/Button", "LoginButton"));
    loginButton->setPosition(CEGUI::UVector2(CEGUI::UDim(0.3f, 0), CEGUI::UDim(0.6f, 0)));
    loginButton->setSize(CEGUI::UVector2(CEGUI::UDim(0.2f, 0), CEGUI::UDim(0.1f, 0)));
    loginButton->setText("登录");
    dialog->addChildWindow(loginButton);
    
    // 取消按钮
    CEGUI::PushButton* cancelButton = static_cast<CEGUI::PushButton*>(
        wmgr.createWindow("MT3Scheme/Button", "CancelButton"));
    cancelButton->setPosition(CEGUI::UVector2(CEGUI::UDim(0.55f, 0), CEGUI::UDim(0.6f, 0)));
    cancelButton->setSize(CEGUI::UVector2(CEGUI::UDim(0.2f, 0), CEGUI::UDim(0.1f, 0)));
    cancelButton->setText("取消");
    dialog->addChildWindow(cancelButton);
    
    return dialog;
}

// 从文件加载布局
CEGUI::Window* LoadLayout(const std::string& layoutName)
{
    std::string fullPath = "cegui/layouts/" + layoutName + ".layout";
    
    CEGUIBinLayoutFileSerializer serializer;
    CEGUI::Window* window = serializer.Deserialize(fullPath);
    
    return window;
}

// Lua 脚本中使用
local mainMenuWindow = CEGUI.LoadLayout("MainMenu")
CEGUI.System:getSingleton():getGUISheet():addChildWindow(mainMenuWindow)

// 登录对话框事件处理器
class LoginDialogHandler
{
public:
    LoginDialogHandler(CEGUI::Window* dialog)
        : m_dialog(dialog)
    {
        // 订阅按钮事件
        CEGUI::PushButton* loginBtn = static_cast<CEGUI::PushButton*>(
            CEGUI::WindowManager::getSingleton().getWindow("LoginButton"));
        
        loginBtn->subscribeEvent(
            CEGUI::PushButton::EventClicked,
            CEGUI::Event::Subscriber(&LoginDialogHandler::OnLoginClicked, this));
        
        CEGUI::PushButton* cancelBtn = static_cast<CEGUI::PushButton*>(
            CEGUI::WindowManager::getSingleton().getWindow("CancelButton"));
        
        cancelBtn->subscribeEvent(
            CEGUI::PushButton::EventClicked,
            CEGUI::Event::Subscriber(&LoginDialogHandler::OnCancelClicked, this));
    }
    
    bool OnLoginClicked(const CEGUI::EventArgs& e)
    {
        // 获取用户名和密码
        CEGUI::Editbox* usernameEdit = static_cast<CEGUI::Editbox*>(
            CEGUI::WindowManager::getSingleton().getWindow("UsernameEdit"));
        CEGUI::Editbox* passwordEdit = static_cast<CEGUI::Editbox*>(
            CEGUI::WindowManager::getSingleton().getWindow("PasswordEdit"));
        
        CEGUI::String username = usernameEdit->getText();
        CEGUI::String password = passwordEdit->getText();
        
        // 执行登录逻辑
        // ...
        
        return true;
    }
    
    bool OnCancelClicked(const CEGUI::EventArgs& e)
    {
        // 关闭对话框
        CEGUI::Window* dialog = static_cast<const CEGUI::WindowEventArgs&>(e).window;
        dialog->hide();
        
        return true;
    }
    
private:
    CEGUI::Window* m_dialog;
};

// 性能优化
#### 批量渲染

class CEGUIBatchRenderer
{
public:
    void AddQuad(const QuadInfo& quad)
    {
        m_quadList.push_back(quad);
    }
    
    void Render()
    {
        // 按纹理分组
        std::map<CCTexture2D*, std::vector<QuadInfo>> batches;
        
        for (const QuadInfo& quad : m_quadList) {
            batches[quad.texture].push_back(quad);
        }
        
        // 批量渲染每个纹理组
        for (auto& pair : batches) {
            RenderBatch(pair.first, pair.second);
        }
        
        m_quadList.clear();
    }
    
private:
    void RenderBatch(CCTexture2D* texture, const std::vector<QuadInfo>& quads)
    {
        // 实现批量渲染逻辑
        // ...
    }
    
    std::vector<QuadInfo> m_quadList;
};

#### 对象池

class OptimizedCEGUIWindow : public CEGUI::Window
{
public:
    static OptimizedCEGUIWindow* create(const std::string& type)
    {
        return WindowPool::AcquireWindow(type);
    }
    
    virtual void destroy()
    {
        WindowPool::ReleaseWindow(this);
    }
    
private:
    class WindowPool
    {
    public:
        static CEGUI::Window* AcquireWindow(const std::string& type)
        {
            auto& pool = m_pools[type];
            
            if (!pool.empty()) {
                CEGUI::Window* window = pool.back();
                pool.pop_back();
                return window;
            }
            
            return CEGUI::WindowManager::getSingleton().createWindow(type);
        }
        
        static void ReleaseWindow(CEGUI::Window* window)
        {
            std::string type = window->getType();
            m_pools[type].push_back(window);
            
            // 重置窗口状态
            window->setPosition(CEGUI::UVector2(CEGUI::UDim(0, 0), CEGUI::UDim(0, 0)));
            window->setSize(CEGUI::UVector2(CEGUI::UDim(0, 0), CEGUI::UDim(0, 0)));
            window->setText("");
            
            // 移除所有子窗口
            while (window->getChildCount() > 0) {
                CEGUI::Window* child = window->getChildAtIdx(0);
                window->removeChildWindow(child);
            }
        }
        
    private:
        static std::map<std::string, std::vector<CEGUI::Window*>> m_pools;
    };
};

#### 智能指针管理

class WindowPtr
{
public:
    WindowPtr(CEGUI::Window* window) : m_window(window) {}
    
    ~WindowPtr()
    {
        if (m_window) {
            CEGUI::WindowManager::getSingleton().destroyWindow(m_window);
        }
    }
    
    CEGUI::Window* get() const { return m_window; }
    CEGUI::Window* operator->() const { return m_window; }
    
    // 禁止拷贝
    WindowPtr(const WindowPtr&) = delete;
    WindowPtr& operator=(const WindowPtr&) = delete;
    
    // 支持移动
    WindowPtr(WindowPtr&& other) noexcept : m_window(other.m_window)
    {
        other.m_window = nullptr;
    }
    
    WindowPtr& operator=(WindowPtr&& other) noexcept
    {
        if (this != &other) {
            if (m_window) {
                CEGUI::WindowManager::getSingleton().destroyWindow(m_window);
            }
            m_window = other.m_window;
            other.m_window = nullptr;
        }
        return *this;
    }
    
private:
    CEGUI::Window* m_window;
};

// 使用示例
void CreateUI()
{
    WindowPtr loginDialog(CreateLoginDialog());
    // 使用 loginDialog...
    // 离开作用域时自动销毁
}

#### 事件连接管理

class EventConnection
{
public:
    EventConnection(CEGUI::Window* window, const std::string& event,
                   CEGUI::Event::Subscriber subscriber)
        : m_window(window)
    {
        m_connection = new CEGUI::Event::Connection(
            window->subscribeEvent(event, subscriber));
    }
    
    ~EventConnection()
    {
        if (m_connection) {
            (*m_connection)->disconnect();
            delete m_connection;
        }
    }
    
private:
    CEGUI::Window* m_window;
    CEGUI::Event::Connection* m_connection;
};

// 使用示例
void SetupEventHandlers()
{
    WindowPtr loginDialog(CreateLoginDialog());
    
    EventConnection loginClick(
        loginDialog->getChild("LoginButton"),
        CEGUI::PushButton::EventClicked,
        CEGUI::Event::Subscriber(&OnLoginClicked));
    
    EventConnection cancelClick(
        loginDialog->getChild("CancelButton"),
        CEGUI::PushButton::EventClicked,
        CEGUI::Event::Subscriber(&OnCancelClicked));
    
    // 事件连接会在 EventConnection 对象销毁时自动断开
}

#### CEGUI 皮肤系统

```xml
<!-- MT3Scheme.looknfeel -->
<LookNFeel>
    <WidgetLook name="MT3Scheme/Button">
        <Property name="NormalImage" value="set:MT3Imageset image:ButtonNormal" />
        <Property name="HoverImage" value="set:MT3Imageset image:ButtonHover" />
        <Property name="PushedImage" value="set:MT3Imageset image:ButtonPressed" />
        <Property name="DisabledImage" value="set:MT3Imageset image:ButtonDisabled" />
        
        <ImagerySection name="label">
            <TextComponent>
                <Area>
                    <Dim type="LeftEdge"><AbsoluteDim value="0" /></Dim>
                    <Dim type="TopEdge"><AbsoluteDim value="0" /></Dim>
                    <Dim type="Width"><UnifiedDim scale="1" type="Width" /></Dim>
                    <Dim type="Height"><UnifiedDim scale="1" type="Height" /></Dim>
                </Area>
                <VertFormat type="CentreAligned" />
                <HorzFormat type="CentreAligned" />
            </TextComponent>
        </ImagerySection>
        
        <StateImagery name="Normal">
            <Layer>
                <Section section="label">
                    <Colours topLeft="FFBBBBBB" topRight="FFFFFFFF" 
                             bottomLeft="FFFFFFFF" bottomRight="FFBBBBBB" />
                </Section>
            </Layer>
        </StateImagery>
        
        <StateImagery name="Hover">
            <Layer>
                <Section section="label">
                    <Colours topLeft="FFDDDDDD" topRight="FFFFFFFF" 
                             bottomLeft="FFFFFFFF" bottomRight="FFDDDDDD" />
                </Section>
            </Layer>
        </StateImagery>
        
        <StateImagery name="Pushed">
            <Layer>
                <Section section="label">
                    <Colours topLeft="FF999999" topRight="FFBBBBBB" 
                             bottomLeft="FFBBBBBB" bottomRight="FF999999" />
                </Section>
            </Layer>
        </StateImagery>
    </WidgetLook>
    
    <WidgetLook name="MT3Scheme/Editbox">
        <Property name="NormalTextColour" value="FF000000" />
        <Property name="SelectedTextColour" value="FFFFFFFF" />
        <Property name="ActiveSelectionColour" value="FF6060FF" />
        <Property name="InactiveSelectionColour" value="FF808080" />
        
        <ImagerySection name="container">
            <FrameComponent>
                <Area>
                    <Dim type="LeftEdge"><AbsoluteDim value="0" /></Dim>
                    <Dim type="TopEdge"><AbsoluteDim value="0" /></Dim>
                    <Dim type="Width"><UnifiedDim scale="1" type="Width" /></Dim>
                    <Dim type="Height"><UnifiedDim scale="1" type="Height" /></Dim>
                </Area>
                <Image type="TopLeftCorner" imageset="MT3Imageset" image="EditboxTopLeft" />
                <Image type="TopRightCorner" imageset="MT3Imageset" image="EditboxTopRight" />
                <Image type="BottomLeftCorner" imageset="MT3Imageset" image="EditboxBottomLeft" />
                <Image type="BottomRightCorner" imageset="MT3Imageset" image="EditboxBottomRight" />
                <Image type="LeftEdge" imageset="MT3Imageset" image="EditboxLeft" />
                <Image type="RightEdge" imageset="MT3Imageset" image="EditboxRight" />
                <Image type="TopEdge" imageset="MT3Imageset" image="EditboxTop" />
                <Image type="BottomEdge" imageset="MT3Imageset" image="EditboxBottom" />
                <Colours topLeft="FFDDDDDD" topRight="FFFFFFFF" 
                         bottomLeft="FFFFFFFF" bottomRight="FFDDDDDD" />
            </FrameComponent>
        </ImagerySection>
        
        <StateImagery name="Enabled">
            <Layer>
                <Section section="container" />
            </Layer>
        </StateImagery>
        
        <StateImagery name="ReadOnly">
            <Layer>
                <Section section="container">
                    <Colours topLeft="FFEEEEEE" topRight="FFEEEEEE" 
                             bottomLeft="FFEEEEEE" bottomRight="FFEEEEEE" />
                </Section>
            </Layer>
        </StateImagery>
        
        <StateImagery name="Disabled">
            <Layer>
                <Section section="container">
                    <Colours topLeft="FFCCCCCC" topRight="FFCCCCCC" 
                             bottomLeft="FFCCCCCC" bottomRight="FFCCCCCC" />
                </Section>
            </Layer>
        </StateImagery>
    </WidgetLook>
    
    <WidgetLook name="MT3Scheme/FrameWindow">
        <Property name="TitlebarFont" value="SimHei-14" />
        <Property name="TitlebarTextColour" value="FFFFFFFF" />
        
        <Child nameSuffix="__auto_titlebar__" type="MT3Scheme/Titlebar">
            <Area>
                <Dim type="LeftEdge"><AbsoluteDim value="0" /></Dim>
                <Dim type="TopEdge"><AbsoluteDim value="0" /></Dim>
                <Dim type="Width"><UnifiedDim scale="1" type="Width" /></Dim>
                <Dim type="Height"><FontDim type="LineSpacing" padding="8" /></Dim>
            </Area>
        </Child>
        
        <Child nameSuffix="__auto_closebutton__" type="MT3Scheme/Button">
            <Area>
                <Dim type="LeftEdge"><AbsoluteDim value="-20" /></Dim>
                <Dim type="TopEdge"><AbsoluteDim value="2" /></Dim>
                <Dim type="Width"><AbsoluteDim value="16" /></Dim>
                <Dim type="Height"><AbsoluteDim value="16" /></Dim>
            </Area>
            <Property name="NormalImage" value="set:MT3Imageset image:CloseButtonNormal" />
            <Property name="HoverImage" value="set:MT3Imageset image:CloseButtonHover" />
            <Property name="PushedImage" value="set:MT3Imageset image:CloseButtonPressed" />
        </Child>
        
        <ImagerySection name="client_with_frame">
            <FrameComponent>
                <Area>
                    <Dim type="LeftEdge"><AbsoluteDim value="0" /></Dim>
                    <Dim type="TopEdge"><AbsoluteDim value="0" /></Dim>
                    <Dim type="Width"><UnifiedDim scale="1" type="Width" /></Dim>
                    <Dim type="Height"><UnifiedDim scale="1" type="Height" /></Dim>
                </Area>
                <Image type="TopLeftCorner" imageset="MT3Imageset" image="WindowTopLeft" />
                <Image type="TopRightCorner" imageset="MT3Imageset" image="WindowTopRight" />
                <Image type="BottomLeftCorner" imageset="MT3Imageset" image="WindowBottomLeft" />
                <Image type="BottomRightCorner" imageset="MT3Imageset" image="WindowBottomRight" />
                <Image type="LeftEdge" imageset="MT3Imageset" image="WindowLeft" />
                <Image type="RightEdge" imageset="MT3Imageset" image="WindowRight" />
                <Image type="TopEdge" imageset="MT3Imageset" image="WindowTop" />
                <Image type="BottomEdge" imageset="MT3Imageset" image="WindowBottom" />
                <Colours topLeft="FFDDDDDD" topRight="FFFFFFFF" 
                         bottomLeft="FFFFFFFF" bottomRight="FFDDDDDD" />
            </FrameComponent>
        </ImagerySection>
        
        <StateImagery name="Enabled">
            <Layer>
                <Section section="client_with_frame" />
            </Layer>
        </StateImagery>
    </WidgetLook>
</LookNFeel>
```

### CEGUI 资源配置

```xml
<!-- MT3Scheme.scheme -->
<GUILayout>
    <WindowSet Filename="CEGUIFalagardWLBase" />
    
    <FalagardMapping>
        <WindowMapping>
            <WindowType TargetType="CEGUI/PushButton" Name="MT3Scheme/Button" />
        </WindowMapping>
        <WindowMapping>
            <WindowType TargetType="CEGUI/Editbox" Name="MT3Scheme/Editbox" />
        </WindowMapping>
        <WindowMapping>
            <WindowType TargetType="CEGUI/FrameWindow" Name="MT3Scheme/FrameWindow" />
        </WindowMapping>
        <WindowMapping>
            <WindowType TargetType="CEGUI/Titlebar" Name="MT3Scheme/Titlebar" />
        </WindowMapping>
        <WindowMapping>
            <WindowType TargetType="CEGUI/Listbox" Name="MT3Scheme/Listbox" />
        </WindowMapping>
        <WindowMapping>
            <WindowType TargetType="CEGUI/Combobox" Name="MT3Scheme/Combobox" />
        </WindowMapping>
        <WindowMapping>
            <WindowType TargetType="CEGUI/Checkbox" Name="MT3Scheme/Checkbox" />
        </WindowMapping>
        <WindowMapping>
            <WindowType TargetType="CEGUI/RadioButton" Name="MT3Scheme/RadioButton" />
        </WindowMapping>
        <WindowMapping>
            <WindowType TargetType="CEGUI/Scrollbar" Name="MT3Scheme/Scrollbar" />
        </WindowMapping>
        <WindowMapping>
            <WindowType TargetType="CEGUI/ProgressBar" Name="MT3Scheme/ProgressBar" />
        </WindowMapping>
    </FalagardMapping>
</GUILayout>
```

### CEGUI 最佳实践

1. **批量渲染**: 尽量减少绘制调用，按纹理分组渲染
2. **对象池**: 重用窗口对象，减少内存分配
3. **智能指针**: 使用 RAII 管理窗口生命周期
4. **事件管理**: 自动断开事件连接，避免内存泄漏
5. **资源预加载**: 在游戏启动时预加载常用资源
6. **异步加载**: 大型资源使用异步加载，避免阻塞主线程
7. **内存监控**: 定期检查内存使用情况，及时释放不需要的资源

MT3 项目的 CEGUI 集成展示了：
- 自定义渲染器实现
- 高效的批量渲染
- 完整的资源管理系统
- 优化的内存管理
- 灵活的事件处理机制

CEGUI 为 MT3 提供了强大而灵活的 UI 系统，适合复杂的 MMO 游戏 UI 需求。

---

## 12.2 CRT 库冲突深度解析

### 问题概述

**错误信息**:
```
错误 LNK2005: __crt_debugger_hook 已经在 MSVCRT.lib(utility_desktop.obj) 中定义
错误 LNK1169: 找到一个或多个多重定义的符号
```

**关键警告**:
```
警告 LNK4098: 默认库"libcmtd.lib"与其他库的使用冲突；请使用 /NODEFAULTLIB:library
```

**发生时机**: 编译 MT3 主程序 (mt3.win32.vcxproj)

### 冲突的根本原因

从编译日志可以看到,问题出在**两个不同的 CRT 库同时被链接**:

```
ucrt.lib(api-ms-win-crt-runtime-l1-1-0.dll) : error LNK2005: __crt_debugger_hook 已经在 MSVCRT.lib(utility_desktop.obj) 中定义
```

这表明:
- **ucrt.lib** (新的 Universal C Runtime) 正在被链接 ✅
- **MSVCRT.lib** (旧的多线程动态 CRT) 也在被链接 ❌

### 为什么会同时链接两个 CRT?

#### 原因 A: 依赖库使用了旧版 CRT

查看依赖库列表:
```xml
<AdditionalDependencies>
  legacy_stdio_definitions.lib;
  Ws2_32.lib;
  opengl32.lib;
  glew32.lib;
  libEGL.lib;        ← 还在依赖列表中!
  libGLESv2.lib;     ← 还在依赖列表中!
  libBox2D.lib;
  libcocos2d.lib;    ← 可能是旧版本编译的
  libCocosDenshion.lib;
  ...
  engine.lib;        ← 可能是旧版本编译的
  FireClient.lib;    ← 可能是旧版本编译的
  ...
</AdditionalDependencies>
```

**关键发现**: 
1. `libEGL.lib` 和 `libGLESv2.lib` **仍然在依赖列表中**!
2. 很多 `.lib` 文件可能是用旧版本 VS 编译的,使用了 MSVCRT.lib

#### 原因 B: 第三方库的 CRT 版本

从警告信息可以看到:
```
MSVCRT.lib(initializers.obj) : warning LNK4098: 默认库"libcmtd.lib"与其他库的使用冲突
```

这说明有些库在链接时自动引入了 MSVCRT.lib

#### 原因 C: 忽略默认库配置不完整

查看 `IgnoreSpecificDefaultLibraries`:
- Debug 配置: 只忽略了 `libcmtd.lib`
- Release 配置: 只忽略了 `libcmt.lib`

但没有忽略 `MSVCRT.lib`!

### CRT 库的选择矩阵

| 配置 | 静态链接 | 动态链接 | VS2015+ |
|------|----------|----------|---------|
| **Debug** | libcmtd.lib | msvcrtd.lib | ucrtd.lib + vcruntimeXXXd.lib |
| **Release** | libcmt.lib | msvcrt.lib | ucrt.lib + vcruntimeXXX.lib |

**当前问题**: 项目使用 `/MD` (动态 CRT),应该链接 `ucrt.lib`,但依赖库引入了 `msvcrt.lib`

### Visual Studio 版本与 CRT 对应关系

| Visual Studio 版本 | 平台工具集 | CRT 版本 | 发布年份 |
|-------------------|------------|----------|----------|
| Visual Studio 2010 | v100 | MSVCR100.dll | 2010 |
| Visual Studio 2012 | v110 | MSVCR110.dll | 2012 |
| **Visual Studio 2013** | **v120** | **MSVCR120.dll** | 2013 |
| Visual Studio 2015 | v140 | UCRT + vcruntime140.dll | 2015 |
| Visual Studio 2017 | v141 | UCRT + vcruntime140.dll | 2017 |
| Visual Studio 2019 | v142 | UCRT + vcruntime140.dll | 2019 |
| Visual Studio 2022 | v143 | UCRT + vcruntime140.dll | 2022 |

#### v120 (VS2013) CRT架构:
```
应用程序 → MSVCR120.dll (单一 CRT DLL)
         → msvcp120.dll (C++ 标准库)
```

#### v140 (VS2015) Universal CRT架构:
```
应用程序 → vcruntime140.dll (C++ 运行时)
         → msvcp140.dll (C++ 标准库)
         → UCRT (Windows 10 组件)
            ├── ucrtbase.dll (通用 CRT 函数)
            └── api-ms-win-crt-*.dll (20多个CRT API集DLL)
               ├── api-ms-win-crt-runtime-l1-1-0.dll
               ├── api-ms-win-crt-stdio-l1-1-0.dll
               ├── api-ms-win-crt-heap-l1-1-0.dll
               ├── api-ms-win-crt-string-l1-1-0.dll
               └── ...
```

**注意**: MT3项目使用VS2013/v120平台工具集，这是项目原始配置，确保与所有依赖库兼容。

#### 运行时库对比

| 配置 | 编译选项 | 运行时 DLL | 导入库 | 调试支持 |
|------|----------|------------|--------|----------|
| **Release - MD** | `/MD` | msvcr140.dll | msvcrt.lib | ❌ 无 |
| **Debug - MDd** | `/MDd` | msvcr140d.dll | msvcrtd.lib | ✅ 完整 |
| **Release - MT** | `/MT` | 无(静态) | libcmt.lib | ❌ 无 |
| **Debug - MTd** | `/MTd` | 无(静态) | libcmtd.lib | ✅ 完整 |

#### CRT 版本检测

```cpp
// 检测当前使用的 CRT 版本
#include <crtdbg.h>
#include <stdio.h>

void detect_crt_version() {
    // _MSC_VER 定义编译器版本
    printf("Compiler version: %d\n", _MSC_VER);
    
    // _MSC_FULL_VER 包含完整版本号
    printf("Full compiler version: %d\n", _MSC_FULL_VER);
    
    // 检测是否使用 UCRT
#ifdef _UCRT
    printf("Using Universal CRT (UCRT)\n");
#else
    printf("Using legacy CRT\n");
#endif
    
    // 检测运行时库类型
#ifdef _MT
    printf("Multithreaded CRT\n");
#else
    printf("Single-threaded CRT\n");
#endif

#ifdef _DLL
    printf("Dynamic linking CRT\n");
#else
    printf("Static linking CRT\n");
#endif

#ifdef _DEBUG
    printf("Debug CRT\n");
#else
    printf("Release CRT\n");
#endif
}
```

#### CRT 兼容性包装器

如果必须混合使用不同版本的 CRT,可以创建兼容性包装器:

```cpp
// crt_compat_wrapper.cpp
#include <corecrt_io.h>
#include <stdio.h>

// 为旧版 CRT 提供兼容性函数
extern "C" {
    // v120中的 __iob_func 在 v140中改为 __acrt_iob_func
    FILE* __cdecl __iob_func(void) {
        // v140中使用__acrt_iob_func替代
        return __acrt_iob_func(0);
    }
    
    // 其他可能的兼容性函数...
}

// crt_compat.def
EXPORTS
    __iob_func
    ; 其他需要导出的函数...

// 编译命令
cl /LD crt_compat_wrapper.cpp /Fecrt_compat.dll /DEF:crt_compat.def
```

然后在项目中链接这个兼容性库:
```xml
<AdditionalDependencies>crt_compat.lib;...</AdditionalDependencies>
```

### 验证方法

#### 检查链接的 CRT 库

使用 `/VERBOSE` 链接器选项查看实际链接的库:
```xml
<Link>
  <AdditionalOptions>/VERBOSE:LIB %(AdditionalOptions)</AdditionalOptions>
</Link>
```

输出示例:
```
1>搜索库
1>  搜索 msvcrtd.lib:
1>    已搜索 C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\lib\msvcrtd.lib
1>  搜索 ucrtd.lib:
1>    已搜索 C:\Program Files (x86)\Windows Kits\10\Lib\10.0.19041.0\ucrt\x86\ucrtd.lib
1>  搜索 MSVCRT.lib:
1>    已搜索 C:\Program Files (x86)\Windows Kits\10\Lib\10.0.19041.0\um\x86\MSVCRT.lib
```

#### 使用 dumpbin 检查符号

```batch
# 检查库中导出的符号
dumpbin /exports msvcr140.dll | findstr __crt_debugger_hook
dumpbin /exports msvcr100.dll | findstr __crt_debugger_hook

# 检查对象文件中引用的符号
dumpbin /symbols some.obj | findstr __crt_debugger_hook
```

#### 运行时检查

```cpp
// 检查运行时加载的 DLL
#include <windows.h>
#include <stdio.h>

void check_loaded_crt() {
    HMODULE hModule = GetModuleHandle(L"msvcr140.dll");
    if (hModule) {
        printf("Loaded: msvcr140.dll\n");
    }
    
    hModule = GetModuleHandle(L"msvcr140d.dll");
    if (hModule) {
        printf("Loaded: msvcr140d.dll\n");
    }
    
    hModule = GetModuleHandle(L"ucrtbase.dll");
    if (hModule) {
        printf("Loaded: ucrtbase.dll\n");
    }
    
    hModule = GetModuleHandle(L"msvcr100.dll");
    if (hModule) {
        printf("Loaded: msvcr100.dll (OLD CRT!)\n");
    }
}
```

### 常见问题解答

#### Q: 为什么不能混合使用不同版本的 CRT?

A: 不同版本的 CRT 有独立的堆管理器、文件描述符表和其他内部状态。如果在一个 CRT 中分配内存,在另一个 CRT 中释放,会导致堆损坏和崩溃。

#### Q: 什么是 Universal CRT (UCRT)?

A: Universal CRT 是从 Windows 10 开始作为操作系统组件提供的 C 运行时库。它解决了以往每个 Visual Studio 版本都需要独立 CRT 的问题,实现了 CRT 的向后兼容和向前兼容。

#### Q: 如何确定应该忽略哪些 CRT 库?

A: 根据项目使用的运行时库类型:
- 使用 `/MD` 或 `/MDd`: 忽略所有静态 CRT (`libcmt.lib`, `libcmtd.lib`)
- 使用 `/MT` 或 `/MTd`: 忽略所有动态 CRT (`msvcrt.lib`, `msvcrtd.lib`)
- 使用 VS2015+: 忽略旧版 CRT (`msvcrt.lib`, `msvcrtd.lib`)

#### Q: 为什么需要 `legacy_stdio_definitions.lib`?

A: VS2015 的 UCRT 移除了一些过时的 stdio 函数,但旧代码可能仍在使用这些函数。`legacy_stdio_definitions.lib` 提供了这些函数的定义,确保兼容性。

### 总结

CRT 库冲突是 VS2015 升级过程中最常见的问题之一。根本原因是 VS2015 引入了全新的 Universal CRT 架构,与旧版 CRT 不兼容。

解决方法:
1. **清理依赖列表**: 移除不需要的库(如 `libEGL.lib`, `libGLESv2.lib`)
2. **统一 CRT 版本**: 确保所有库使用相同版本的 CRT
3. **正确忽略冲突库**: 在链接器设置中忽略冲突的 CRT 库
4. **考虑重新编译**: 对于复杂项目,考虑使用 VS2015 重新编译所有依赖库

---

## 12.3 libEGL/ANGLE 链接问题

### 问题描述

**错误信息**:
```
4>LINK : fatal error LNK1104: 无法打开文件"libEGL.lib"
```

**发生时机**: 编译 `cocos2d-win32.vc2010.sln` 时

### 问题根本原因

通过深入分析,发现这是一个**平台配置错误**:

#### ANGLE 项目简介

- **ANGLE** (Almost Native Graphics Layer Engine) 是 Google 开发的项目
- 用于将 **OpenGL ES API** 调用转换为 **DirectX** 调用
- 主要用于移动平台(WinRT/WP8)在 Windows 上运行

#### Win32 vs 移动平台的差异

| 平台 | 使用的图形 API | 需要的库 |
|------|----------------|----------|
| **Win32 桌面** | 原生 OpenGL (通过 GLEW) | `opengl32.lib`, `glew32.lib` |
| **WinRT/WP8** | OpenGL ES (通过 ANGLE) | `libEGL.lib`, `libGLESv2.lib` |

#### 项目配置错误

- `cocos2d-win32.vcxproj` 中错误地包含了 ANGLE 库依赖
- 但 `cocos2d-win32.vc2010.sln` 解决方案中**没有包含 ANGLE 项目**
- Win32 平台根本**不需要**也**不应该使用** ANGLE

#### 代码证据

**Win32 平台头文件** (`cocos2dx/platform/win32/CCGL.h`):
```cpp
#ifndef __CCGL_H__
#define __CCGL_H__

#include "GL/glew.h"  // 使用原生 OpenGL

#define CC_GL_DEPTH24_STENCIL8    GL_DEPTH24_STENCIL8

#endif // __CCGL_H__
```

**移动平台代码** (WinRT/WP8):
```cpp
// 使用 EGL
EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
eglInitialize(display, NULL, NULL);
// ... 更多 EGL 代码
```

从代码搜索结果可以确认:
- 所有 `EGL` 和 `GLES` 引用都在移动平台代码中
- Win32 平台完全不使用 EGL/GLES

### 解决方案

从 `cocos2d-win32.vcxproj` 中移除不需要的 ANGLE 库依赖:

#### 修改内容

**文件**: `cocos2d-2.0-rc2-x-2.0.1/cocos2dx/proj.win32/cocos2d-win32.vcxproj`

##### 修改 1: Debug 配置 (第 72 行)

```xml
<!-- 修改前 -->
<AdditionalDependencies>opengl32.lib;glew32.lib;libxml2.lib;libzlib.lib;libjpeg.lib;winmm.lib;libpng.lib;libtiff.lib;libiconv.lib;pthreadVCE2.lib;libwebp.lib;libEGL.lib;libGLESv2.lib;libBox2D.lib;%(AdditionalDependencies)</AdditionalDependencies>

<!-- 修改后 -->
<AdditionalDependencies>opengl32.lib;glew32.lib;libxml2.lib;libzlib.lib;libjpeg.lib;winmm.lib;libpng.lib;libtiff.lib;libiconv.lib;pthreadVCE2.lib;libwebp.lib;libBox2D.lib;%(AdditionalDependencies)</AdditionalDependencies>
```

##### 修改 2: Release 配置 (第 110 行)

```xml
<!-- 修改前 -->
<AdditionalDependencies>opengl32.lib;glew32.lib;libxml2.lib;libzlib.lib;libjpeg.lib;winmm.lib;libtiff.lib;libpng.lib;libiconv.lib;pthreadVCE2.lib;libEGL.lib;libGLESv2.lib;libBox2D.lib;libwebp.lib;%(AdditionalDependencies)</AdditionalDependencies>

<!-- 修改后 -->
<AdditionalDependencies>opengl32.lib;glew32.lib;libxml2.lib;libzlib.lib;libjpeg.lib;winmm.lib;libtiff.lib;libpng.lib;libiconv.lib;pthreadVCE2.lib;libBox2D.lib;libwebp.lib;%(AdditionalDependencies)</AdditionalDependencies>
```

**变更说明**: 移除了 `libEGL.lib` 和 `libGLESv2.lib`

### 技术背景

#### OpenGL vs OpenGL ES

| 特性 | OpenGL | OpenGL ES |
|------|--------|-----------|
| **目标平台** | 桌面系统 | 嵌入式/移动设备 |
| **功能集** | 完整功能 | 精简子集 |
| **Windows 支持** | 原生支持 | 需要 ANGLE 转换层 |
| **MT3 Win32 使用** | ✅ 是 | ❌ 否 |

#### GLEW (OpenGL Extension Wrangler)

- 用于加载和管理 OpenGL 扩展
- Win32 版本的 Cocos2d-x 通过 GLEW 使用原生 OpenGL
- 已经在 `cocos2dx/platform/third_party/win32/libraries/glew32.lib` 中提供

#### ANGLE 在 Cocos2d-x 中的使用

Cocos2d-x 支持多个平台,不同平台使用不同的图形后端:

```
Cocos2d-x 架构
├── Win32
│   └── 原生 OpenGL (通过 GLEW)
├── WinRT
│   └── OpenGL ES (通过 ANGLE)
├── Windows Phone 8
│   └── OpenGL ES (通过 ANGLE)
├── Android
│   └── OpenGL ES (原生)
└── iOS
    └── OpenGL ES (原生)
```

### 验证方法

编译 `cocos2d-win32.vc2010.sln`:

```batch
REM 使用提供的批处理脚本
build_cocos2d.bat
```

或者直接编译:

```batch
call "C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\vcvarsall.bat" x86
devenv.com "cocos2d-2.0-rc2-x-2.0.1\cocos2d-win32.vc2010.sln" /Rebuild "Release|Win32"
```

**预期结果**: 
- ✅ 编译成功,没有 LNK1104 错误
- ✅ 生成 `libcocos2d.dll` 和 `libcocos2d.lib`
- ✅ 位于 `cocos2d-2.0-rc2-x-2.0.1/Release.win32/` 目录

### 深入分析: 为什么会出现这个错误?

#### 跨平台代码共享导致的问题

Cocos2d-x 是一个跨平台引擎,代码库中包含多个平台的实现:

```
cocos2dx/platform/
├── win32/
│   ├── CCGL.h          # 使用 GLEW
│   └── ...
├── winrt/
│   ├── CCGL.h          # 使用 EGL
│   └── ...
├── wp8/
│   ├── CCGL.h          # 使用 EGL
│   └── ...
└── ...
```

在项目配置过程中,可能错误地将移动平台的库依赖添加到了 Win32 项目中。

#### ANGLE 项目结构

如果需要使用 ANGLE,项目结构应该是:

```
angleproject/
├── src/
│   ├── libEGL/
│   ├── libGLESv2/
│   ├── translator/
│   └── preprocessor/
└── lib/
    ├── $(Configuration)/
    │   ├── libEGL.lib
    │   ├── libGLESv2.lib
    │   ├── translator_common.lib
    │   ├── translator_hlsl.lib
    │   └── preprocessor.lib
```

但在 MT3 项目中,这些库文件并不存在,因为 Win32 不需要 ANGLE。

### 移除 ANGLE 依赖的影响分析

#### 对 Win32 平台的影响

- ✅ **无负面影响**: Win32 平台原本就不需要 ANGLE
- ✅ **编译成功**: 解决了 LNK1104 错误
- ✅ **运行正常**: 使用原生 OpenGL,性能更好

#### 对跨平台支持的影响

- ⚠️ **需要注意**: 如果将来需要支持 WinRT/WP8,需要重新添加 ANGLE 支持
- ⚠️ **文档更新**: 需要明确区分不同平台的库依赖

### 最佳实践建议

#### 1. 平台特定配置

为不同平台创建不同的项目配置:

```xml
<!-- Win32 平台 -->
<ItemDefinitionGroup Condition="'$(Platform)'=='Win32'">
  <Link>
    <AdditionalDependencies>opengl32.lib;glew32.lib;...</AdditionalDependencies>
  </Link>
</ItemDefinitionGroup>

<!-- WinRT 平台 -->
<ItemDefinitionGroup Condition="'$(Platform)'=='WinRT'">
  <Link>
    <AdditionalDependencies>libEGL.lib;libGLESv2.lib;...</AdditionalDependencies>
  </Link>
</ItemDefinitionGroup>
```

#### 2. 条件编译

使用预处理器指令区分平台:

```cpp
#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)
    #include "GL/glew.h"  // Win32 使用原生 OpenGL
#elif (CC_TARGET_PLATFORM == CC_PLATFORM_WINRT)
    #include <EGL/egl.h>  // WinRT 使用 EGL
#endif
```

#### 3. 清晰的文档

在项目文档中明确说明不同平台的依赖:

```
## 平台依赖

### Win32
- OpenGL: 原生支持
- 依赖库: opengl32.lib, glew32.lib
- 不需要: ANGLE

### WinRT
- OpenGL: 通过 ANGLE
- 依赖库: libEGL.lib, libGLESv2.lib
- 需要: ANGLE 项目
```

### 总结

#### 问题本质

- 这是一个**跨平台配置污染**问题
- 移动平台(WinRT/WP8)的配置错误地混入了 Win32 桌面项目
- 导致 Win32 项目尝试链接本不需要的移动平台库

#### 解决思路

1. **识别平台差异**: Win32 使用 OpenGL,移动平台使用 OpenGL ES
2. **清理配置**: 移除 Win32 项目中的 ANGLE 依赖
3. **保持简洁**: Win32 只需要 `opengl32.lib` 和 `glew32.lib`

#### 相关修复

这是 MT3 项目 VS2015 兼容性修复系列的第 4 个问题:

1. ✅ C1083 - SimpleAudioEngine.h 头文件路径
2. ✅ LNK2005/LNK1169 - CRT 库冲突
3. ✅ C2011 - timespec 重定义
4. ✅ **LNK1104 - libEGL.lib 缺失 (本文档)**

---

## 技术专题交叉引用

### 相关文档

1. [06-编译完整指南.md](./06-编译完整指南.md) - 包含 CEGUI 编译步骤
2. [10-编译问题排查.md](./10-编译问题排查.md) - 包含 CRT 冲突和 libEGL 问题排查
3. [archive/MT3编译问题修复总结.md](./archive/MT3编译问题修复总结.md) - 包含已修复的问题列表
4. [archive/Debug编译错误分析与解决方案.md](./archive/Debug编译错误分析与解决方案.md) - 包含 Debug 配置的 CRT 问题
5. [archive/MT3项目编译问题分析与解决方案.md](./archive/MT3项目编译问题分析与解决方案.md) - 包含项目依赖关系分析

### 专题关联图

```
MT3 项目技术专题
├── 12.1 CEGUI UI 系统
│   ├── 依赖: FreeType, SILLY, pcre
│   ├── 相关: UI 渲染, 资源管理
│   └── 文档: CEGUI技术集成指南.md
├── 12.2 CRT 库冲突
│   ├── 影响: 所有链接阶段
│   ├── 相关: VS2015 兼容性, 运行时库
│   └── 文档: CRT库冲突深度分析.md
└── 12.3 libEGL/ANGLE 链接问题
    ├── 影响: OpenGL 渲染
    ├── 相关: 跨平台支持, 图形 API
    └── 文档: libEGL链接错误修复说明.md
```

---

## 常见问题解答

### Q: CEGUI 相关问题

**Q: CEGUI 渲染性能如何优化?**
A: 
- 使用批量渲染减少绘制调用
- 按纹理分组渲染
- 实现对象池重用窗口对象
- 使用智能指针管理生命周期

**Q: CEGUI 如何与 Cocos2d-x 坐标系兼容?**
A: 
- CEGUI 使用左上角为原点
- Cocos2d-x 使用左下角为原点
- 需要进行 Y 坐标翻转: `y = screenHeight - ceguiY`

**Q: CEGUI 资源如何管理?**
A: 
- 使用二进制布局系统提高加载速度
- 预加载常用资源
- 实现异步加载大型资源
- 定期检查内存使用情况

### Q: CRT 相关问题

**Q: 为什么不能混合使用不同版本的 CRT?**
A: 不同版本的 CRT 有独立的堆管理器、文件描述符表和其他内部状态。如果在一个 CRT 中分配内存,在另一个 CRT 中释放,会导致堆损坏和崩溃。

**Q: 什么是 Universal CRT (UCRT)?**
A: Universal CRT 是从 Windows 10 开始作为操作系统组件提供的 C 运行时库。它解决了以往每个 Visual Studio 版本都需要独立 CRT 的问题,实现了 CRT 的向后兼容和向前兼容。

**Q: 如何确定应该忽略哪些 CRT 库?**
A: 根据项目使用的运行时库类型:
- 使用 `/MD` 或 `/MDd`: 忽略所有静态 CRT (`libcmt.lib`, `libcmtd.lib`)
- 使用 `/MT` 或 `/MTd`: 忽略所有动态 CRT (`msvcrt.lib`, `msvcrtd.lib`)
- 使用 VS2015+: 忽略旧版 CRT (`msvcrt.lib`, `msvcrtd.lib`)

### Q: libEGL/ANGLE 相关问题

**Q: Win32 平台为什么不使用 ANGLE?**
A: Win32 平台原生支持 OpenGL,不需要通过 ANGLE 转换。使用原生 OpenGL 性能更好,且不需要额外的转换层。

**Q: 什么情况下需要使用 ANGLE?**
A: 
- WinRT/WP8 平台(不支持原生 OpenGL)
- 需要使用 OpenGL ES 特定功能的场景
- 跨平台统一使用 OpenGL ES API

**Q: 如何判断项目是否需要 ANGLE?**
A: 检查代码中是否使用了 EGL/GLES API:
- 如果只使用 `#include "GL/glew.h"`,不需要 ANGLE
- 如果使用 `#include <EGL/egl.h>`,需要 ANGLE

---

**文档版本**: 2.0  
**最后更新**: 2025-10-12  
**文档状态**: 已完成  
**文档来源**: 
- [toolchains/CEGUI技术集成指南.md](./toolchains/CEGUI技术集成指南.md)
- [CRT库冲突深度分析.md](./CRT库冲突深度分析.md)
- [libEGL链接错误修复说明.md](./libEGL链接错误修复说明.md)